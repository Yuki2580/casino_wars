"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot";
exports.ids = ["vendor-chunks/valibot"];
exports.modules = {

/***/ "(rsc)/./node_modules/valibot/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/valibot/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIC_REGEX: () => (/* binding */ BIC_REGEX),\n/* harmony export */   BrandSymbol: () => (/* binding */ BrandSymbol),\n/* harmony export */   CUID2_REGEX: () => (/* binding */ CUID2_REGEX),\n/* harmony export */   DECIMAL_REGEX: () => (/* binding */ DECIMAL_REGEX),\n/* harmony export */   EMAIL_REGEX: () => (/* binding */ EMAIL_REGEX),\n/* harmony export */   EMOJI_REGEX: () => (/* binding */ EMOJI_REGEX),\n/* harmony export */   HEXADECIMAL_REGEX: () => (/* binding */ HEXADECIMAL_REGEX),\n/* harmony export */   HEX_COLOR_REGEX: () => (/* binding */ HEX_COLOR_REGEX),\n/* harmony export */   IMEI_REGEX: () => (/* binding */ IMEI_REGEX),\n/* harmony export */   IPV4_REGEX: () => (/* binding */ IPV4_REGEX),\n/* harmony export */   IPV6_REGEX: () => (/* binding */ IPV6_REGEX),\n/* harmony export */   ISO_DATE_REGEX: () => (/* binding */ ISO_DATE_REGEX),\n/* harmony export */   ISO_DATE_TIME_REGEX: () => (/* binding */ ISO_DATE_TIME_REGEX),\n/* harmony export */   ISO_TIMESTAMP_REGEX: () => (/* binding */ ISO_TIMESTAMP_REGEX),\n/* harmony export */   ISO_TIME_REGEX: () => (/* binding */ ISO_TIME_REGEX),\n/* harmony export */   ISO_TIME_SECOND_REGEX: () => (/* binding */ ISO_TIME_SECOND_REGEX),\n/* harmony export */   ISO_WEEK_REGEX: () => (/* binding */ ISO_WEEK_REGEX),\n/* harmony export */   MAC48_REGEX: () => (/* binding */ MAC48_REGEX),\n/* harmony export */   MAC64_REGEX: () => (/* binding */ MAC64_REGEX),\n/* harmony export */   OCTAL_REGEX: () => (/* binding */ OCTAL_REGEX),\n/* harmony export */   ULID_REGEX: () => (/* binding */ ULID_REGEX),\n/* harmony export */   UUID_REGEX: () => (/* binding */ UUID_REGEX),\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   actionIssue: () => (/* binding */ actionIssue),\n/* harmony export */   actionOutput: () => (/* binding */ actionOutput),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   anyAsync: () => (/* binding */ anyAsync),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   bic: () => (/* binding */ bic),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   bigintAsync: () => (/* binding */ bigintAsync),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   blobAsync: () => (/* binding */ blobAsync),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   booleanAsync: () => (/* binding */ booleanAsync),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   coerceAsync: () => (/* binding */ coerceAsync),\n/* harmony export */   creditCard: () => (/* binding */ creditCard),\n/* harmony export */   cuid2: () => (/* binding */ cuid2),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   dateAsync: () => (/* binding */ dateAsync),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   defaultArgs: () => (/* binding */ defaultArgs),\n/* harmony export */   deleteGlobalConfig: () => (/* binding */ deleteGlobalConfig),\n/* harmony export */   deleteGlobalMessage: () => (/* binding */ deleteGlobalMessage),\n/* harmony export */   deleteSchemaMessage: () => (/* binding */ deleteSchemaMessage),\n/* harmony export */   deleteSpecificMessage: () => (/* binding */ deleteSpecificMessage),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   enumAsync: () => (/* binding */ enumAsync),\n/* harmony export */   enum_: () => (/* binding */ enum_),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   forwardAsync: () => (/* binding */ forwardAsync),\n/* harmony export */   getDefault: () => (/* binding */ getDefault),\n/* harmony export */   getDefaultAsync: () => (/* binding */ getDefaultAsync),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getDefaultsAsync: () => (/* binding */ getDefaultsAsync),\n/* harmony export */   getFallback: () => (/* binding */ getFallback),\n/* harmony export */   getFallbackAsync: () => (/* binding */ getFallbackAsync),\n/* harmony export */   getFallbacks: () => (/* binding */ getFallbacks),\n/* harmony export */   getFallbacksAsync: () => (/* binding */ getFallbacksAsync),\n/* harmony export */   getGlobalConfig: () => (/* binding */ getGlobalConfig),\n/* harmony export */   getGlobalMessage: () => (/* binding */ getGlobalMessage),\n/* harmony export */   getSchemaMessage: () => (/* binding */ getSchemaMessage),\n/* harmony export */   getSpecificMessage: () => (/* binding */ getSpecificMessage),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   hexColor: () => (/* binding */ hexColor),\n/* harmony export */   hexadecimal: () => (/* binding */ hexadecimal),\n/* harmony export */   i18n: () => (/* binding */ i18n),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   instanceAsync: () => (/* binding */ instanceAsync),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersect: () => (/* binding */ intersect),\n/* harmony export */   intersectAsync: () => (/* binding */ intersectAsync),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isLuhnAlgo: () => (/* binding */ isLuhnAlgo),\n/* harmony export */   isOfType: () => (/* binding */ isOfType),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   lazyAsync: () => (/* binding */ lazyAsync),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   literalAsync: () => (/* binding */ literalAsync),\n/* harmony export */   mac: () => (/* binding */ mac),\n/* harmony export */   mac48: () => (/* binding */ mac48),\n/* harmony export */   mac64: () => (/* binding */ mac64),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mergeAsync: () => (/* binding */ mergeAsync),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   nanAsync: () => (/* binding */ nanAsync),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   neverAsync: () => (/* binding */ neverAsync),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   notBytes: () => (/* binding */ notBytes),\n/* harmony export */   notLength: () => (/* binding */ notLength),\n/* harmony export */   notSize: () => (/* binding */ notSize),\n/* harmony export */   notValue: () => (/* binding */ notValue),\n/* harmony export */   nullAsync: () => (/* binding */ nullAsync),\n/* harmony export */   null_: () => (/* binding */ null_),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   numberAsync: () => (/* binding */ numberAsync),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   octal: () => (/* binding */ octal),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   omitAsync: () => (/* binding */ omitAsync),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   pickAsync: () => (/* binding */ pickAsync),\n/* harmony export */   picklist: () => (/* binding */ picklist),\n/* harmony export */   picklistAsync: () => (/* binding */ picklistAsync),\n/* harmony export */   pipeResult: () => (/* binding */ pipeResult),\n/* harmony export */   pipeResultAsync: () => (/* binding */ pipeResultAsync),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   restAndDefaultArgs: () => (/* binding */ restAndDefaultArgs),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   schemaIssue: () => (/* binding */ schemaIssue),\n/* harmony export */   schemaResult: () => (/* binding */ schemaResult),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   setGlobalConfig: () => (/* binding */ setGlobalConfig),\n/* harmony export */   setGlobalMessage: () => (/* binding */ setGlobalMessage),\n/* harmony export */   setSchemaMessage: () => (/* binding */ setSchemaMessage),\n/* harmony export */   setSpecificMessage: () => (/* binding */ setSpecificMessage),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   special: () => (/* binding */ special),\n/* harmony export */   specialAsync: () => (/* binding */ specialAsync),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   stringAsync: () => (/* binding */ stringAsync),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   symbolAsync: () => (/* binding */ symbolAsync),\n/* harmony export */   toCustom: () => (/* binding */ toCustom),\n/* harmony export */   toCustomAsync: () => (/* binding */ toCustomAsync),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toTrimmed: () => (/* binding */ toTrimmed),\n/* harmony export */   toTrimmedEnd: () => (/* binding */ toTrimmedEnd),\n/* harmony export */   toTrimmedStart: () => (/* binding */ toTrimmedStart),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   undefinedAsync: () => (/* binding */ undefinedAsync),\n/* harmony export */   undefined_: () => (/* binding */ undefined_),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unknownAsync: () => (/* binding */ unknownAsync),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   variant: () => (/* binding */ variant),\n/* harmony export */   variantAsync: () => (/* binding */ variantAsync),\n/* harmony export */   voidAsync: () => (/* binding */ voidAsync),\n/* harmony export */   void_: () => (/* binding */ void_)\n/* harmony export */ });\n// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n    return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce((flatErrors, issue)=>{\n        if (issue.path) {\n            if (issue.path.every(({ key })=>typeof key === \"string\" || typeof key === \"number\")) {\n                const path = issue.path.map(({ key })=>key).join(\".\");\n                if (flatErrors.nested[path]) {\n                    flatErrors.nested[path].push(issue.message);\n                } else {\n                    flatErrors.nested[path] = [\n                        issue.message\n                    ];\n                }\n            }\n        } else {\n            if (flatErrors.root) {\n                flatErrors.root.push(issue.message);\n            } else {\n                flatErrors.root = [\n                    issue.message\n                ];\n            }\n        }\n        return flatErrors;\n    }, {\n        nested: {}\n    });\n}\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n    /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */ constructor(issues){\n        super(issues[0].message);\n        this.name = \"ValiError\";\n        this.issues = issues;\n    }\n};\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n    return schema;\n}\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n    return {\n        ...schema,\n        _parse (input, config) {\n            return schema._parse(action(input), config);\n        }\n    };\n}\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n    return {\n        ...schema,\n        async _parse (input, config) {\n            return schema._parse(await action(input), config);\n        }\n    };\n}\n// src/utils/actionIssue/actionIssue.ts\nfunction actionIssue(context, reference, input, label, received) {\n    return {\n        issues: [\n            {\n                context,\n                reference,\n                input,\n                label,\n                received\n            }\n        ]\n    };\n}\n// src/utils/actionOutput/actionOutput.ts\nfunction actionOutput(output) {\n    return {\n        output\n    };\n}\n// src/utils/defaultArgs/defaultArgs.ts\nfunction defaultArgs(arg1, arg2) {\n    return Array.isArray(arg1) ? [\n        void 0,\n        arg1\n    ] : [\n        arg1,\n        arg2\n    ];\n}\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config) {\n    store = {\n        ...store,\n        ...config\n    };\n}\nfunction getGlobalConfig(config) {\n    return {\n        lang: config?.lang ?? store?.lang,\n        message: config?.message,\n        abortEarly: config?.abortEarly ?? store?.abortEarly,\n        abortPipeEarly: config?.abortPipeEarly ?? store?.abortPipeEarly,\n        skipPipe: config?.skipPipe ?? store?.skipPipe\n    };\n}\nfunction deleteGlobalConfig() {\n    store = void 0;\n}\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n    if (!store2) store2 = /* @__PURE__ */ new Map();\n    store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n    return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n    store2?.delete(lang);\n}\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n    if (!store3) store3 = /* @__PURE__ */ new Map();\n    store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n    return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n    store3?.delete(lang);\n}\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n    if (!store4) store4 = /* @__PURE__ */ new Map();\n    if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n    store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n    return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n    store4?.get(reference)?.delete(lang);\n}\n// src/utils/i18n/i18n.ts\nfunction i18n(schema, context, reference, config, issue) {\n    const message = context.message ?? getSpecificMessage(reference, issue.lang) ?? (schema ? getSchemaMessage(issue.lang) : null) ?? config?.message ?? getGlobalMessage(issue.lang) ?? issue.message;\n    return typeof message === \"function\" ? message(issue) : message;\n}\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n    const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n    let length2 = number2.length;\n    let bit = 1;\n    let sum = 0;\n    while(length2){\n        const value2 = +number2[--length2];\n        bit ^= 1;\n        sum += bit ? [\n            0,\n            2,\n            4,\n            6,\n            8,\n            1,\n            3,\n            5,\n            7,\n            9\n        ][value2] : value2;\n    }\n    return sum % 10 === 0;\n}\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n    return object2.type === type;\n}\n// src/utils/schemaResult/schemaResult.ts\nfunction schemaResult(typed, output, issues) {\n    return {\n        typed,\n        output,\n        issues\n    };\n}\n// src/utils/stringify/stringify.ts\nfunction stringify(input) {\n    let type = typeof input;\n    if (type === \"object\") {\n        type = input ? Object.getPrototypeOf(input).constructor.name : \"null\";\n    }\n    return type === \"string\" ? `\"${input}\"` : type === \"number\" || type === \"bigint\" || type === \"boolean\" ? `${input}` : type;\n}\n// src/utils/pipeResult/utils/pipeIssue/pipeIssue.ts\nfunction pipeIssue(context, config, issue) {\n    const received = issue.received ?? stringify(issue.input);\n    const schemaIssue2 = {\n        reason: context.type,\n        context: issue.context.type,\n        expected: issue.context.expects,\n        received,\n        message: `Invalid ${issue.label}: ${issue.context.expects ? `Expected ${issue.context.expects} but r` : \"R\"}eceived ${received}`,\n        input: issue.input,\n        requirement: issue.context.requirement,\n        path: issue.path,\n        lang: config?.lang,\n        abortEarly: config?.abortEarly,\n        abortPipeEarly: config?.abortPipeEarly,\n        skipPipe: config?.skipPipe\n    };\n    schemaIssue2.message = i18n(false, issue.context, issue.reference, config, schemaIssue2);\n    return schemaIssue2;\n}\n// src/utils/pipeResult/pipeResult.ts\nfunction pipeResult(context, input, config, issues) {\n    if (context.pipe && !config?.skipPipe) {\n        for (const action of context.pipe){\n            const result = action._parse(input);\n            if (result.issues) {\n                for (const actionIssue2 of result.issues){\n                    const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n                    issues ? issues.push(schemaIssue2) : issues = [\n                        schemaIssue2\n                    ];\n                }\n                if (config?.abortEarly || config?.abortPipeEarly) {\n                    break;\n                }\n            } else {\n                input = result.output;\n            }\n        }\n    }\n    return schemaResult(true, input, issues);\n}\n// src/utils/pipeResult/pipeResultAsync.ts\nasync function pipeResultAsync(context, input, config, issues) {\n    if (context.pipe && !config?.skipPipe) {\n        for (const action of context.pipe){\n            const result = await action._parse(input);\n            if (result.issues) {\n                for (const actionIssue2 of result.issues){\n                    const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n                    issues ? issues.push(schemaIssue2) : issues = [\n                        schemaIssue2\n                    ];\n                }\n                if (config?.abortEarly || config?.abortPipeEarly) {\n                    break;\n                }\n            } else {\n                input = result.output;\n            }\n        }\n    }\n    return schemaResult(true, input, issues);\n}\n// src/utils/restAndDefaultArgs/restAndDefaultArgs.ts\nfunction restAndDefaultArgs(arg1, arg2, arg3) {\n    if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n        const [error2, pipe2] = defaultArgs(arg2, arg3);\n        return [\n            arg1,\n            error2,\n            pipe2\n        ];\n    }\n    const [error, pipe] = defaultArgs(arg1, arg2);\n    return [\n        void 0,\n        error,\n        pipe\n    ];\n}\n// src/utils/schemaIssue/schemaIssue.ts\nfunction schemaIssue(context, reference, input, config, other) {\n    const received = stringify(input);\n    const expected = other?.expected ?? context.expects;\n    const issue = {\n        reason: other?.reason ?? \"type\",\n        context: context.type,\n        expected,\n        received,\n        message: `Invalid type: Expected ${expected} but received ${received}`,\n        input,\n        path: other?.path,\n        issues: other?.issues,\n        lang: config?.lang,\n        abortEarly: config?.abortEarly,\n        abortPipeEarly: config?.abortPipeEarly,\n        skipPipe: config?.skipPipe\n    };\n    issue.message = i18n(true, context, reference, config, issue);\n    return {\n        typed: false,\n        output: input,\n        issues: [\n            issue\n        ]\n    };\n}\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n    return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n    return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        _parse (input, config) {\n            const result = schema._parse(input, config);\n            return result.issues ? schemaResult(true, getFallback(this, {\n                input,\n                issues: result.issues\n            })) : result;\n        }\n    };\n}\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        async _parse (input, config) {\n            const result = await schema._parse(input, config);\n            return result.issues ? schemaResult(true, await getFallbackAsync(this, {\n                input,\n                issues: result.issues\n            })) : result;\n        }\n    };\n}\n// src/methods/forward/forward.ts\nfunction forward(validation, pathList) {\n    return {\n        ...validation,\n        _parse (input) {\n            const result = validation._parse(input);\n            if (result.issues) {\n                for (const issue of result.issues){\n                    let pathInput = input;\n                    for (const key of pathList){\n                        const pathValue = pathInput[key];\n                        issue.input = pathValue;\n                        const pathItem = {\n                            type: \"unknown\",\n                            origin: \"value\",\n                            input: pathInput,\n                            key,\n                            value: pathValue\n                        };\n                        issue.path ? issue.path.push(pathItem) : issue.path = [\n                            pathItem\n                        ];\n                        if (!pathValue) {\n                            break;\n                        }\n                        pathInput = pathValue;\n                    }\n                }\n            }\n            return result;\n        }\n    };\n}\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(validation, pathList) {\n    return {\n        ...validation,\n        async _parse (input) {\n            const result = await validation._parse(input);\n            if (result.issues) {\n                for (const issue of result.issues){\n                    let pathInput = input;\n                    for (const key of pathList){\n                        const pathValue = pathInput[key];\n                        issue.input = pathValue;\n                        const pathItem = {\n                            type: \"unknown\",\n                            origin: \"value\",\n                            input: pathInput,\n                            key,\n                            value: pathValue\n                        };\n                        issue.path ? issue.path.push(pathItem) : issue.path = [\n                            pathItem\n                        ];\n                        if (!pathValue) {\n                            break;\n                        }\n                        pathInput = pathValue;\n                    }\n                }\n            }\n            return result;\n        }\n    };\n}\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n    return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n    return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n    if (schema.default !== void 0) {\n        return getDefault(schema);\n    }\n    if (isOfType(\"object\", schema)) {\n        return Object.fromEntries(Object.entries(schema.entries).map(([key, value2])=>[\n                key,\n                getDefaults(value2)\n            ]));\n    }\n    if (isOfType(\"tuple\", schema)) {\n        return schema.items.map(getDefaults);\n    }\n    return void 0;\n}\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n    if (schema.default !== void 0) {\n        return getDefaultAsync(schema);\n    }\n    if (isOfType(\"object\", schema)) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await getDefaultsAsync(value2)\n            ])));\n    }\n    if (isOfType(\"tuple\", schema)) {\n        return Promise.all(schema.items.map(getDefaultsAsync));\n    }\n    return void 0;\n}\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n    if (schema.fallback !== void 0) {\n        return getFallback(schema);\n    }\n    if (isOfType(\"object\", schema)) {\n        return Object.fromEntries(Object.entries(schema.entries).map(([key, value2])=>[\n                key,\n                getFallbacks(value2)\n            ]));\n    }\n    if (isOfType(\"tuple\", schema)) {\n        return schema.items.map(getFallbacks);\n    }\n    return void 0;\n}\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n    if (schema.fallback !== void 0) {\n        return getFallbackAsync(schema);\n    }\n    if (isOfType(\"object\", schema)) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await getFallbacksAsync(value2)\n            ])));\n    }\n    if (isOfType(\"tuple\", schema)) {\n        return Promise.all(schema.items.map(getFallbacksAsync));\n    }\n    return void 0;\n}\n// src/methods/is/is.ts\nfunction is(schema, input, config) {\n    return !schema._parse(input, {\n        abortEarly: true,\n        skipPipe: getGlobalConfig(config)?.skipPipe\n    }).issues;\n}\n// src/schemas/any/any.ts\nfunction any(pipe) {\n    return {\n        type: \"any\",\n        expects: \"any\",\n        async: false,\n        pipe,\n        _parse (input, config) {\n            return pipeResult(this, input, config);\n        }\n    };\n}\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n    return {\n        type: \"any\",\n        expects: \"any\",\n        async: true,\n        pipe,\n        async _parse (input, config) {\n            return pipeResultAsync(this, input, config);\n        }\n    };\n}\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"array\",\n        expects: \"Array\",\n        async: false,\n        item,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (Array.isArray(input)) {\n                let typed = true;\n                let issues;\n                const output = [];\n                for(let key = 0; key < input.length; key++){\n                    const value2 = input[key];\n                    const result = this.item._parse(value2, config);\n                    if (result.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of result.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = result.issues;\n                        }\n                        if (config?.abortEarly) {\n                            typed = false;\n                            break;\n                        }\n                    }\n                    if (!result.typed) {\n                        typed = false;\n                    }\n                    output.push(result.output);\n                }\n                if (typed) {\n                    return pipeResult(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, array, input, config);\n        }\n    };\n}\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"array\",\n        expects: \"Array\",\n        async: true,\n        item,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (Array.isArray(input)) {\n                let typed = true;\n                let issues;\n                const output = [];\n                await Promise.all(input.map(async (value2, key)=>{\n                    if (!(config?.abortEarly && issues)) {\n                        const result = await this.item._parse(value2, config);\n                        if (!(config?.abortEarly && issues)) {\n                            if (result.issues) {\n                                const pathItem = {\n                                    type: \"array\",\n                                    origin: \"value\",\n                                    input,\n                                    key,\n                                    value: value2\n                                };\n                                for (const issue of result.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    issues?.push(issue);\n                                }\n                                if (!issues) {\n                                    issues = result.issues;\n                                }\n                                if (config?.abortEarly) {\n                                    typed = false;\n                                    throw null;\n                                }\n                            }\n                            if (!result.typed) {\n                                typed = false;\n                            }\n                            output[key] = result.output;\n                        }\n                    }\n                })).catch(()=>null);\n                if (typed) {\n                    return pipeResultAsync(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, arrayAsync, input, config);\n        }\n    };\n}\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"bigint\",\n        expects: \"bigint\",\n        async: false,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (typeof input === \"bigint\") {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, bigint, input, config);\n        }\n    };\n}\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"bigint\",\n        expects: \"bigint\",\n        async: true,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (typeof input === \"bigint\") {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, bigintAsync, input, config);\n        }\n    };\n}\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"blob\",\n        expects: \"Blob\",\n        async: false,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input instanceof Blob) {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, blob, input, config);\n        }\n    };\n}\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"blob\",\n        expects: \"Blob\",\n        async: true,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input instanceof Blob) {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, blobAsync, input, config);\n        }\n    };\n}\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"boolean\",\n        expects: \"boolean\",\n        async: false,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (typeof input === \"boolean\") {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, boolean, input, config);\n        }\n    };\n}\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"boolean\",\n        expects: \"boolean\",\n        async: true,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (typeof input === \"boolean\") {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, booleanAsync, input, config);\n        }\n    };\n}\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"date\",\n        expects: \"Date\",\n        async: false,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input instanceof Date && !isNaN(input.getTime())) {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, date, input, config);\n        }\n    };\n}\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"date\",\n        expects: \"Date\",\n        async: true,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input instanceof Date && !isNaN(input.getTime())) {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, dateAsync, input, config);\n        }\n    };\n}\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n    const values = Object.values(enum__);\n    return {\n        type: \"enum\",\n        expects: values.map(stringify).join(\" | \"),\n        async: false,\n        enum: enum__,\n        message,\n        _parse (input, config) {\n            if (values.includes(input)) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, enum_, input, config);\n        }\n    };\n}\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message) {\n    const values = Object.values(enum_2);\n    return {\n        type: \"enum\",\n        expects: values.map(stringify).join(\" | \"),\n        async: true,\n        enum: enum_2,\n        message,\n        async _parse (input, config) {\n            if (values.includes(input)) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, enumAsync, input, config);\n        }\n    };\n}\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"instance\",\n        expects: class_.name,\n        async: false,\n        class: class_,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input instanceof this.class) {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, instance, input, config);\n        }\n    };\n}\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"instance\",\n        expects: class_.name,\n        async: true,\n        class: class_,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input instanceof this.class) {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, instanceAsync, input, config);\n        }\n    };\n}\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n    if (typeof output1 === typeof output2) {\n        if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n            return {\n                output: output1\n            };\n        }\n        if (Array.isArray(output1) && Array.isArray(output2)) {\n            if (output1.length === output2.length) {\n                const array2 = [];\n                for(let index = 0; index < output1.length; index++){\n                    const result = mergeOutputs(output1[index], output2[index]);\n                    if (result.invalid) {\n                        return result;\n                    }\n                    array2.push(result.output);\n                }\n                return {\n                    output: array2\n                };\n            }\n            return {\n                invalid: true\n            };\n        }\n        if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n            const object2 = {\n                ...output1,\n                ...output2\n            };\n            for(const key in output1){\n                if (key in output2) {\n                    const result = mergeOutputs(output1[key], output2[key]);\n                    if (result.invalid) {\n                        return result;\n                    }\n                    object2[key] = result.output;\n                }\n            }\n            return {\n                output: object2\n            };\n        }\n    }\n    return {\n        invalid: true\n    };\n}\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"intersect\",\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" & \"),\n        async: false,\n        options,\n        message,\n        pipe,\n        _parse (input, config) {\n            let typed = true;\n            let issues;\n            let output;\n            const outputs = [];\n            for (const schema of this.options){\n                const result = schema._parse(input, config);\n                if (result.issues) {\n                    if (issues) {\n                        for (const issue of result.issues){\n                            issues.push(issue);\n                        }\n                    } else {\n                        issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                        typed = false;\n                        break;\n                    }\n                }\n                if (!result.typed) {\n                    typed = false;\n                }\n                outputs.push(result.output);\n            }\n            if (typed) {\n                output = outputs[0];\n                for(let index = 1; index < outputs.length; index++){\n                    const result = mergeOutputs(output, outputs[index]);\n                    if (result.invalid) {\n                        return schemaIssue(this, intersect, input, config);\n                    }\n                    output = result.output;\n                }\n                return pipeResult(this, output, config, issues);\n            }\n            return schemaResult(false, output, issues);\n        }\n    };\n}\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"intersect\",\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" & \"),\n        async: true,\n        options,\n        message,\n        pipe,\n        async _parse (input, config) {\n            let typed = true;\n            let issues;\n            let output;\n            const outputs = [];\n            await Promise.all(this.options.map(async (schema)=>{\n                if (!(config?.abortEarly && issues)) {\n                    const result = await schema._parse(input, config);\n                    if (!(config?.abortEarly && issues)) {\n                        if (result.issues) {\n                            if (issues) {\n                                for (const issue of result.issues){\n                                    issues.push(issue);\n                                }\n                            } else {\n                                issues = result.issues;\n                            }\n                            if (config?.abortEarly) {\n                                typed = false;\n                                throw null;\n                            }\n                        }\n                        if (!result.typed) {\n                            typed = false;\n                        }\n                        outputs.push(result.output);\n                    }\n                }\n            })).catch(()=>null);\n            if (typed) {\n                output = outputs[0];\n                for(let index = 1; index < outputs.length; index++){\n                    const result = mergeOutputs(output, outputs[index]);\n                    if (result.invalid) {\n                        return schemaIssue(this, intersectAsync, input, config);\n                    }\n                    output = result.output;\n                }\n                return pipeResultAsync(this, output, config, issues);\n            }\n            return schemaResult(false, output, issues);\n        }\n    };\n}\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n    return {\n        type: \"lazy\",\n        expects: \"unknown\",\n        async: false,\n        getter,\n        _parse (input, config) {\n            return this.getter(input)._parse(input, config);\n        }\n    };\n}\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n    return {\n        type: \"lazy\",\n        expects: \"unknown\",\n        async: true,\n        getter,\n        async _parse (input, config) {\n            return (await this.getter(input))._parse(input, config);\n        }\n    };\n}\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n    return {\n        type: \"literal\",\n        expects: stringify(literal_),\n        async: false,\n        literal: literal_,\n        message,\n        _parse (input, config) {\n            if (input === this.literal) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, literal, input, config);\n        }\n    };\n}\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message) {\n    return {\n        type: \"literal\",\n        expects: stringify(literal2),\n        async: true,\n        literal: literal2,\n        message,\n        async _parse (input, config) {\n            if (input === this.literal) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, literalAsync, input, config);\n        }\n    };\n}\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n    const [message, pipe] = defaultArgs(arg3, arg4);\n    return {\n        type: \"map\",\n        expects: \"Map\",\n        async: false,\n        key,\n        value: value2,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input instanceof Map) {\n                let typed = true;\n                let issues;\n                const output = /* @__PURE__ */ new Map();\n                for (const [inputKey, inputValue] of input.entries()){\n                    let pathItem;\n                    const keyResult = this.key._parse(inputKey, config);\n                    if (keyResult.issues) {\n                        pathItem = {\n                            type: \"map\",\n                            origin: \"key\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyResult.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = keyResult.issues;\n                        }\n                        if (config?.abortEarly) {\n                            typed = false;\n                            break;\n                        }\n                    }\n                    const valueResult = this.value._parse(inputValue, config);\n                    if (valueResult.issues) {\n                        pathItem = pathItem ?? {\n                            type: \"map\",\n                            origin: \"value\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueResult.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = valueResult.issues;\n                        }\n                        if (config?.abortEarly) {\n                            typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyResult.typed || !valueResult.typed) {\n                        typed = false;\n                    }\n                    output.set(keyResult.output, valueResult.output);\n                }\n                if (typed) {\n                    return pipeResult(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, map, input, config);\n        }\n    };\n}\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n    const [message, pipe] = defaultArgs(arg3, arg4);\n    return {\n        type: \"map\",\n        expects: \"Map\",\n        async: true,\n        key,\n        value: value2,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input instanceof Map) {\n                let typed = true;\n                let issues;\n                const output = /* @__PURE__ */ new Map();\n                await Promise.all(Array.from(input.entries()).map(async ([inputKey, inputValue])=>{\n                    let pathItem;\n                    const [keyResult, valueResult] = await Promise.all([\n                        {\n                            schema: this.key,\n                            value: inputKey,\n                            origin: \"key\"\n                        },\n                        {\n                            schema: this.value,\n                            value: inputValue,\n                            origin: \"value\"\n                        }\n                    ].map(async ({ schema, value: value3, origin })=>{\n                        if (!(config?.abortEarly && issues)) {\n                            const result = await schema._parse(value3, config);\n                            if (!(config?.abortEarly && issues)) {\n                                if (result.issues) {\n                                    pathItem = pathItem ?? {\n                                        type: \"map\",\n                                        origin,\n                                        input,\n                                        key: inputKey,\n                                        value: inputValue\n                                    };\n                                    for (const issue of result.issues){\n                                        if (issue.path) {\n                                            issue.path.unshift(pathItem);\n                                        } else {\n                                            issue.path = [\n                                                pathItem\n                                            ];\n                                        }\n                                        issues?.push(issue);\n                                    }\n                                    if (!issues) {\n                                        issues = result.issues;\n                                    }\n                                    if (config?.abortEarly) {\n                                        throw null;\n                                    }\n                                }\n                                return result;\n                            }\n                        }\n                    })).catch(()=>[]);\n                    if (!keyResult?.typed || !valueResult?.typed) {\n                        typed = false;\n                    }\n                    if (keyResult && valueResult) {\n                        output.set(keyResult.output, valueResult.output);\n                    }\n                }));\n                if (typed) {\n                    return pipeResultAsync(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, mapAsync, input, config);\n        }\n    };\n}\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n    return {\n        type: \"nan\",\n        expects: \"NaN\",\n        async: false,\n        message,\n        _parse (input, config) {\n            if (Number.isNaN(input)) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, nan, input, config);\n        }\n    };\n}\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message) {\n    return {\n        type: \"nan\",\n        expects: \"NaN\",\n        async: true,\n        message,\n        async _parse (input, config) {\n            if (Number.isNaN(input)) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, nanAsync, input, config);\n        }\n    };\n}\n// src/schemas/never/never.ts\nfunction never(message) {\n    return {\n        type: \"never\",\n        expects: \"never\",\n        async: false,\n        message,\n        _parse (input, config) {\n            return schemaIssue(this, never, input, config);\n        }\n    };\n}\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message) {\n    return {\n        type: \"never\",\n        expects: \"never\",\n        async: true,\n        message,\n        async _parse (input, config) {\n            return schemaIssue(this, neverAsync, input, config);\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n    return {\n        type: \"non_nullable\",\n        expects: \"!null\",\n        async: false,\n        wrapped,\n        message,\n        _parse (input, config) {\n            if (input === null) {\n                return schemaIssue(this, nonNullable, input, config);\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n    return {\n        type: \"non_nullable\",\n        expects: \"!null\",\n        async: true,\n        wrapped,\n        message,\n        async _parse (input, config) {\n            if (input === null) {\n                return schemaIssue(this, nonNullableAsync, input, config);\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n    return {\n        type: \"non_nullish\",\n        expects: \"!null & !undefined\",\n        async: false,\n        wrapped,\n        message,\n        _parse (input, config) {\n            if (input === null || input === void 0) {\n                return schemaIssue(this, nonNullish, input, config);\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n    return {\n        type: \"non_nullish\",\n        expects: \"!null & !undefined\",\n        async: true,\n        wrapped,\n        message,\n        async _parse (input, config) {\n            if (input === null || input === void 0) {\n                return schemaIssue(this, nonNullishAsync, input, config);\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n    return {\n        type: \"non_optional\",\n        expects: \"!undefined\",\n        async: false,\n        wrapped,\n        message,\n        _parse (input, config) {\n            if (input === void 0) {\n                return schemaIssue(this, nonOptional, input, config);\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n    return {\n        type: \"non_optional\",\n        expects: \"!undefined\",\n        async: true,\n        wrapped,\n        message,\n        async _parse (input, config) {\n            if (input === void 0) {\n                return schemaIssue(this, nonOptionalAsync, input, config);\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n    return {\n        type: \"nullable\",\n        expects: `${wrapped.expects} | null`,\n        async: false,\n        wrapped,\n        default: default_,\n        _parse (input, config) {\n            if (input === null) {\n                const override = getDefault(this);\n                if (override === void 0) {\n                    return schemaResult(true, input);\n                }\n                input = override;\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n    return {\n        type: \"nullable\",\n        expects: `${wrapped.expects} | null`,\n        async: true,\n        wrapped,\n        default: default_,\n        async _parse (input, config) {\n            if (input === null) {\n                const override = await getDefaultAsync(this);\n                if (override === void 0) {\n                    return schemaResult(true, input);\n                }\n                input = override;\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n    return {\n        type: \"nullish\",\n        expects: `${wrapped.expects} | null | undefined`,\n        async: false,\n        wrapped,\n        default: default_,\n        _parse (input, config) {\n            if (input === null || input === void 0) {\n                const override = getDefault(this);\n                if (override === void 0) {\n                    return schemaResult(true, input);\n                }\n                input = override;\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n    return {\n        type: \"nullish\",\n        expects: `${wrapped.expects} | null | undefined`,\n        async: true,\n        wrapped,\n        default: default_,\n        async _parse (input, config) {\n            if (input === null || input === void 0) {\n                const override = await getDefaultAsync(this);\n                if (override === void 0) {\n                    return schemaResult(true, input);\n                }\n                input = override;\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/null/null.ts\nfunction null_(message) {\n    return {\n        type: \"null\",\n        expects: \"null\",\n        async: false,\n        message,\n        _parse (input, config) {\n            if (input === null) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, null_, input, config);\n        }\n    };\n}\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message) {\n    return {\n        type: \"null\",\n        expects: \"null\",\n        async: true,\n        message,\n        async _parse (input, config) {\n            if (input === null) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, nullAsync, input, config);\n        }\n    };\n}\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"number\",\n        expects: \"number\",\n        async: false,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (typeof input === \"number\" && !isNaN(input)) {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, number, input, config);\n        }\n    };\n}\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"number\",\n        expects: \"number\",\n        async: true,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (typeof input === \"number\" && !isNaN(input)) {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, numberAsync, input, config);\n        }\n    };\n}\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    let cachedEntries;\n    return {\n        type: \"object\",\n        expects: \"Object\",\n        async: false,\n        entries,\n        rest,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input && typeof input === \"object\") {\n                cachedEntries = cachedEntries ?? Object.entries(this.entries);\n                let typed = true;\n                let issues;\n                const output = {};\n                for (const [key, schema] of cachedEntries){\n                    const value2 = input[key];\n                    const result = schema._parse(value2, config);\n                    if (result.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of result.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = result.issues;\n                        }\n                        if (config?.abortEarly) {\n                            typed = false;\n                            break;\n                        }\n                    }\n                    if (!result.typed) {\n                        typed = false;\n                    }\n                    if (result.output !== void 0 || key in input) {\n                        output[key] = result.output;\n                    }\n                }\n                if (this.rest && !(config?.abortEarly && issues)) {\n                    for(const key in input){\n                        if (!(key in this.entries)) {\n                            const value2 = input[key];\n                            const result = this.rest._parse(value2, config);\n                            if (result.issues) {\n                                const pathItem = {\n                                    type: \"object\",\n                                    origin: \"value\",\n                                    input,\n                                    key,\n                                    value: value2\n                                };\n                                for (const issue of result.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    issues?.push(issue);\n                                }\n                                if (!issues) {\n                                    issues = result.issues;\n                                }\n                                if (config?.abortEarly) {\n                                    typed = false;\n                                    break;\n                                }\n                            }\n                            if (!result.typed) {\n                                typed = false;\n                            }\n                            output[key] = result.output;\n                        }\n                    }\n                }\n                if (typed) {\n                    return pipeResult(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, object, input, config);\n        }\n    };\n}\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    let cachedEntries;\n    return {\n        type: \"object\",\n        expects: \"Object\",\n        async: true,\n        entries,\n        rest,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input && typeof input === \"object\") {\n                cachedEntries = cachedEntries ?? Object.entries(this.entries);\n                let typed = true;\n                let issues;\n                const output = {};\n                await Promise.all([\n                    Promise.all(cachedEntries.map(async ([key, schema])=>{\n                        if (!(config?.abortEarly && issues)) {\n                            const value2 = input[key];\n                            const result = await schema._parse(value2, config);\n                            if (!(config?.abortEarly && issues)) {\n                                if (result.issues) {\n                                    const pathItem = {\n                                        type: \"object\",\n                                        origin: \"value\",\n                                        input,\n                                        key,\n                                        value: value2\n                                    };\n                                    for (const issue of result.issues){\n                                        if (issue.path) {\n                                            issue.path.unshift(pathItem);\n                                        } else {\n                                            issue.path = [\n                                                pathItem\n                                            ];\n                                        }\n                                        issues?.push(issue);\n                                    }\n                                    if (!issues) {\n                                        issues = result.issues;\n                                    }\n                                    if (config?.abortEarly) {\n                                        typed = false;\n                                        throw null;\n                                    }\n                                }\n                                if (!result.typed) {\n                                    typed = false;\n                                }\n                                if (result.output !== void 0 || key in input) {\n                                    output[key] = result.output;\n                                }\n                            }\n                        }\n                    })),\n                    this.rest && Promise.all(Object.entries(input).map(async ([key, value2])=>{\n                        if (!(config?.abortEarly && issues)) {\n                            if (!(key in this.entries)) {\n                                const result = await this.rest._parse(value2, config);\n                                if (!(config?.abortEarly && issues)) {\n                                    if (result.issues) {\n                                        const pathItem = {\n                                            type: \"object\",\n                                            origin: \"value\",\n                                            input,\n                                            key,\n                                            value: value2\n                                        };\n                                        for (const issue of result.issues){\n                                            if (issue.path) {\n                                                issue.path.unshift(pathItem);\n                                            } else {\n                                                issue.path = [\n                                                    pathItem\n                                                ];\n                                            }\n                                            issues?.push(issue);\n                                        }\n                                        if (!issues) {\n                                            issues = result.issues;\n                                        }\n                                        if (config?.abortEarly) {\n                                            typed = false;\n                                            throw null;\n                                        }\n                                    }\n                                    if (!result.typed) {\n                                        typed = false;\n                                    }\n                                    output[key] = result.output;\n                                }\n                            }\n                        }\n                    }))\n                ]).catch(()=>null);\n                if (typed) {\n                    return pipeResultAsync(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, objectAsync, input, config);\n        }\n    };\n}\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n    return {\n        type: \"optional\",\n        expects: `${wrapped.expects} | undefined`,\n        async: false,\n        wrapped,\n        default: default_,\n        _parse (input, config) {\n            if (input === void 0) {\n                const override = getDefault(this);\n                if (override === void 0) {\n                    return schemaResult(true, input);\n                }\n                input = override;\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n    return {\n        type: \"optional\",\n        expects: `${wrapped.expects} | undefined`,\n        async: true,\n        wrapped,\n        default: default_,\n        async _parse (input, config) {\n            if (input === void 0) {\n                const override = await getDefaultAsync(this);\n                if (override === void 0) {\n                    return schemaResult(true, input);\n                }\n                input = override;\n            }\n            return this.wrapped._parse(input, config);\n        }\n    };\n}\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n    return {\n        type: \"picklist\",\n        expects: options.map(stringify).join(\" | \"),\n        async: false,\n        options,\n        message,\n        _parse (input, config) {\n            if (this.options.includes(input)) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, picklist, input, config);\n        }\n    };\n}\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message) {\n    return {\n        type: \"picklist\",\n        expects: options.map(stringify).join(\" | \"),\n        async: true,\n        options,\n        message,\n        async _parse (input, config) {\n            if (this.options.includes(input)) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, picklistAsync, input, config);\n        }\n    };\n}\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"string\",\n        expects: \"string\",\n        async: false,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (typeof input === \"string\") {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, string, input, config);\n        }\n    };\n}\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n    const [message, pipe] = defaultArgs(arg1, arg2);\n    return {\n        type: \"string\",\n        expects: \"string\",\n        async: true,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (typeof input === \"string\") {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, stringAsync, input, config);\n        }\n    };\n}\n// src/schemas/record/utils/recordArgs/recordArgs.ts\nfunction recordArgs(arg1, arg2, arg3, arg4) {\n    if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n        const [message2, pipe2] = defaultArgs(arg3, arg4);\n        return [\n            arg1,\n            arg2,\n            message2,\n            pipe2\n        ];\n    }\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return [\n        string(),\n        arg1,\n        message,\n        pipe\n    ];\n}\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\n    \"__proto__\",\n    \"prototype\",\n    \"constructor\"\n];\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n    const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n    return {\n        type: \"record\",\n        expects: \"Object\",\n        async: false,\n        key,\n        value: value2,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input && typeof input === \"object\") {\n                let typed = true;\n                let issues;\n                const output = {};\n                for (const [inputKey, inputValue] of Object.entries(input)){\n                    if (!BLOCKED_KEYS.includes(inputKey)) {\n                        let pathItem;\n                        const keyResult = this.key._parse(inputKey, config);\n                        if (keyResult.issues) {\n                            pathItem = {\n                                type: \"record\",\n                                origin: \"key\",\n                                input,\n                                key: inputKey,\n                                value: inputValue\n                            };\n                            for (const issue of keyResult.issues){\n                                issue.path = [\n                                    pathItem\n                                ];\n                                issues?.push(issue);\n                            }\n                            if (!issues) {\n                                issues = keyResult.issues;\n                            }\n                            if (config?.abortEarly) {\n                                typed = false;\n                                break;\n                            }\n                        }\n                        const valueResult = this.value._parse(inputValue, config);\n                        if (valueResult.issues) {\n                            pathItem = pathItem ?? {\n                                type: \"record\",\n                                origin: \"value\",\n                                input,\n                                key: inputKey,\n                                value: inputValue\n                            };\n                            for (const issue of valueResult.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                issues?.push(issue);\n                            }\n                            if (!issues) {\n                                issues = valueResult.issues;\n                            }\n                            if (config?.abortEarly) {\n                                typed = false;\n                                break;\n                            }\n                        }\n                        if (!keyResult.typed || !valueResult.typed) {\n                            typed = false;\n                        }\n                        if (keyResult.typed) {\n                            output[keyResult.output] = valueResult.output;\n                        }\n                    }\n                }\n                if (typed) {\n                    return pipeResult(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, record, input, config);\n        }\n    };\n}\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n    const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n    return {\n        type: \"record\",\n        expects: \"Object\",\n        async: true,\n        key,\n        value: value2,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input && typeof input === \"object\") {\n                let typed = true;\n                let issues;\n                const output = {};\n                await Promise.all(// Note: `Object.entries(...)` converts each key to a string\n                Object.entries(input).map(async ([inputKey, inputValue])=>{\n                    if (!BLOCKED_KEYS.includes(inputKey)) {\n                        let pathItem;\n                        const [keyResult, valueResult] = await Promise.all([\n                            {\n                                schema: this.key,\n                                value: inputKey,\n                                origin: \"key\"\n                            },\n                            {\n                                schema: this.value,\n                                value: inputValue,\n                                origin: \"value\"\n                            }\n                        ].map(async ({ schema, value: value3, origin })=>{\n                            if (!(config?.abortEarly && issues)) {\n                                const result = await schema._parse(value3, config);\n                                if (!(config?.abortEarly && issues)) {\n                                    if (result.issues) {\n                                        pathItem = pathItem ?? {\n                                            type: \"record\",\n                                            origin,\n                                            input,\n                                            key: inputKey,\n                                            value: inputValue\n                                        };\n                                        for (const issue of result.issues){\n                                            if (issue.path) {\n                                                issue.path.unshift(pathItem);\n                                            } else {\n                                                issue.path = [\n                                                    pathItem\n                                                ];\n                                            }\n                                            issues?.push(issue);\n                                        }\n                                        if (!issues) {\n                                            issues = result.issues;\n                                        }\n                                        if (config?.abortEarly) {\n                                            throw null;\n                                        }\n                                    }\n                                    return result;\n                                }\n                            }\n                        })).catch(()=>[]);\n                        if (!keyResult?.typed || !valueResult?.typed) {\n                            typed = false;\n                        }\n                        if (keyResult?.typed && valueResult) {\n                            output[keyResult.output] = valueResult.output;\n                        }\n                    }\n                }));\n                if (typed) {\n                    return pipeResultAsync(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, recordAsync, input, config);\n        }\n    };\n}\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"set\",\n        expects: \"Set\",\n        async: false,\n        value: value2,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input instanceof Set) {\n                let key = 0;\n                let typed = true;\n                let issues;\n                const output = /* @__PURE__ */ new Set();\n                for (const inputValue of input){\n                    const result = this.value._parse(inputValue, config);\n                    if (result.issues) {\n                        const pathItem = {\n                            type: \"set\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: inputValue\n                        };\n                        for (const issue of result.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = result.issues;\n                        }\n                        if (config?.abortEarly) {\n                            typed = false;\n                            break;\n                        }\n                    }\n                    if (!result.typed) {\n                        typed = false;\n                    }\n                    output.add(result.output);\n                    key++;\n                }\n                if (typed) {\n                    return pipeResult(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, set, input, config);\n        }\n    };\n}\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"set\",\n        expects: \"Set\",\n        async: true,\n        value: value2,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input instanceof Set) {\n                let typed = true;\n                let issues;\n                const output = /* @__PURE__ */ new Set();\n                await Promise.all(Array.from(input.values()).map(async (inputValue, key)=>{\n                    if (!(config?.abortEarly && issues)) {\n                        const result = await this.value._parse(inputValue, config);\n                        if (!(config?.abortEarly && issues)) {\n                            if (result.issues) {\n                                const pathItem = {\n                                    type: \"set\",\n                                    origin: \"value\",\n                                    input,\n                                    key,\n                                    value: inputValue\n                                };\n                                for (const issue of result.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    issues?.push(issue);\n                                }\n                                if (!issues) {\n                                    issues = result.issues;\n                                }\n                                if (config?.abortEarly) {\n                                    typed = false;\n                                    throw null;\n                                }\n                            }\n                            if (!result.typed) {\n                                typed = false;\n                            }\n                            output.add(result.output);\n                        }\n                    }\n                })).catch(()=>null);\n                if (typed) {\n                    return pipeResultAsync(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, setAsync, input, config);\n        }\n    };\n}\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"special\",\n        expects: \"unknown\",\n        async: false,\n        check,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (this.check(input)) {\n                return pipeResult(this, input, config);\n            }\n            return schemaIssue(this, special, input, config);\n        }\n    };\n}\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"special\",\n        expects: \"unknown\",\n        async: true,\n        check,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (await this.check(input)) {\n                return pipeResultAsync(this, input, config);\n            }\n            return schemaIssue(this, specialAsync, input, config);\n        }\n    };\n}\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n    return {\n        type: \"symbol\",\n        expects: \"symbol\",\n        async: false,\n        message,\n        _parse (input, config) {\n            if (typeof input === \"symbol\") {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, symbol, input, config);\n        }\n    };\n}\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message) {\n    return {\n        type: \"symbol\",\n        expects: \"symbol\",\n        async: true,\n        message,\n        async _parse (input, config) {\n            if (typeof input === \"symbol\") {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, symbolAsync, input, config);\n        }\n    };\n}\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return {\n        type: \"tuple\",\n        expects: \"Array\",\n        async: false,\n        items,\n        rest,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (Array.isArray(input)) {\n                let typed = true;\n                let issues;\n                const output = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const result = this.items[key]._parse(value2, config);\n                    if (result.issues) {\n                        const pathItem = {\n                            type: \"tuple\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of result.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = result.issues;\n                        }\n                        if (config?.abortEarly) {\n                            typed = false;\n                            break;\n                        }\n                    }\n                    if (!result.typed) {\n                        typed = false;\n                    }\n                    output[key] = result.output;\n                }\n                if (this.rest && !(config?.abortEarly && issues)) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        const value2 = input[key];\n                        const result = this.rest._parse(value2, config);\n                        if (result.issues) {\n                            const pathItem = {\n                                type: \"tuple\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of result.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                issues?.push(issue);\n                            }\n                            if (!issues) {\n                                issues = result.issues;\n                            }\n                            if (config?.abortEarly) {\n                                typed = false;\n                                break;\n                            }\n                        }\n                        if (!result.typed) {\n                            typed = false;\n                        }\n                        output[key] = result.output;\n                    }\n                }\n                if (typed) {\n                    return pipeResult(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, tuple, input, config);\n        }\n    };\n}\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return {\n        type: \"tuple\",\n        expects: \"Array\",\n        async: true,\n        items,\n        rest,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (Array.isArray(input)) {\n                let typed = true;\n                let issues;\n                const output = [];\n                await Promise.all([\n                    // Parse schema of each tuple item\n                    Promise.all(this.items.map(async (schema, key)=>{\n                        if (!(config?.abortEarly && issues)) {\n                            const value2 = input[key];\n                            const result = await schema._parse(value2, config);\n                            if (!(config?.abortEarly && issues)) {\n                                if (result.issues) {\n                                    const pathItem = {\n                                        type: \"tuple\",\n                                        origin: \"value\",\n                                        input,\n                                        key,\n                                        value: value2\n                                    };\n                                    for (const issue of result.issues){\n                                        if (issue.path) {\n                                            issue.path.unshift(pathItem);\n                                        } else {\n                                            issue.path = [\n                                                pathItem\n                                            ];\n                                        }\n                                        issues?.push(issue);\n                                    }\n                                    if (!issues) {\n                                        issues = result.issues;\n                                    }\n                                    if (config?.abortEarly) {\n                                        typed = false;\n                                        throw null;\n                                    }\n                                }\n                                if (!result.typed) {\n                                    typed = false;\n                                }\n                                output[key] = result.output;\n                            }\n                        }\n                    })),\n                    // If necessary parse schema of each rest item\n                    this.rest && Promise.all(input.slice(this.items.length).map(async (value2, index)=>{\n                        if (!(config?.abortEarly && issues)) {\n                            const key = this.items.length + index;\n                            const result = await this.rest._parse(value2, config);\n                            if (!(config?.abortEarly && issues)) {\n                                if (result.issues) {\n                                    const pathItem = {\n                                        type: \"tuple\",\n                                        origin: \"value\",\n                                        input,\n                                        key,\n                                        value: value2\n                                    };\n                                    for (const issue of result.issues){\n                                        if (issue.path) {\n                                            issue.path.unshift(pathItem);\n                                        } else {\n                                            issue.path = [\n                                                pathItem\n                                            ];\n                                        }\n                                        issues?.push(issue);\n                                    }\n                                    if (!issues) {\n                                        issues = result.issues;\n                                    }\n                                    if (config?.abortEarly) {\n                                        typed = false;\n                                        throw null;\n                                    }\n                                }\n                                if (!result.typed) {\n                                    typed = false;\n                                }\n                                output[key] = result.output;\n                            }\n                        }\n                    }))\n                ]).catch(()=>null);\n                if (typed) {\n                    return pipeResultAsync(this, output, config, issues);\n                }\n                return schemaResult(false, output, issues);\n            }\n            return schemaIssue(this, tupleAsync, input, config);\n        }\n    };\n}\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n    return {\n        type: \"undefined\",\n        expects: \"undefined\",\n        async: false,\n        message,\n        _parse (input, config) {\n            if (input === void 0) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, undefined_, input, config);\n        }\n    };\n}\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message) {\n    return {\n        type: \"undefined\",\n        expects: \"undefined\",\n        async: true,\n        message,\n        async _parse (input, config) {\n            if (input === void 0) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, undefinedAsync, input, config);\n        }\n    };\n}\n// src/schemas/union/utils/subissues/subissues.ts\nfunction subissues(results) {\n    let issues;\n    if (results) {\n        for (const result of results){\n            if (issues) {\n                for (const issue of result.issues){\n                    issues.push(issue);\n                }\n            } else {\n                issues = result.issues;\n            }\n        }\n    }\n    return issues;\n}\n// src/schemas/union/union.ts\nfunction union(options, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"union\",\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" | \"),\n        async: false,\n        options,\n        message,\n        pipe,\n        _parse (input, config) {\n            let validResult;\n            let untypedResults;\n            let typedResults;\n            for (const schema of this.options){\n                const result = schema._parse(input, config);\n                if (result.typed) {\n                    if (!result.issues) {\n                        validResult = result;\n                        break;\n                    } else {\n                        typedResults ? typedResults.push(result) : typedResults = [\n                            result\n                        ];\n                    }\n                } else {\n                    untypedResults ? untypedResults.push(result) : untypedResults = [\n                        result\n                    ];\n                }\n            }\n            if (validResult) {\n                return pipeResult(this, validResult.output, config);\n            }\n            if (typedResults?.length) {\n                const firstResult = typedResults[0];\n                return pipeResult(this, firstResult.output, config, // Hint: If there is more than one typed result, we use a general\n                // union issue with subissues because the issues could contradict\n                // each other.\n                typedResults.length === 1 ? firstResult.issues : schemaIssue(this, union, input, config, {\n                    reason: \"union\",\n                    issues: subissues(typedResults)\n                }).issues);\n            }\n            if (untypedResults?.length === 1) {\n                return untypedResults[0];\n            }\n            return schemaIssue(this, union, input, config, {\n                issues: subissues(untypedResults)\n            });\n        }\n    };\n}\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, arg2, arg3) {\n    const [message, pipe] = defaultArgs(arg2, arg3);\n    return {\n        type: \"union\",\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" | \"),\n        async: true,\n        options,\n        message,\n        pipe,\n        async _parse (input, config) {\n            let validResult;\n            let untypedResults;\n            let typedResults;\n            for (const schema of this.options){\n                const result = await schema._parse(input, config);\n                if (result.typed) {\n                    if (!result.issues) {\n                        validResult = result;\n                        break;\n                    } else {\n                        typedResults ? typedResults.push(result) : typedResults = [\n                            result\n                        ];\n                    }\n                } else {\n                    untypedResults ? untypedResults.push(result) : untypedResults = [\n                        result\n                    ];\n                }\n            }\n            if (validResult) {\n                return pipeResultAsync(this, validResult.output, config);\n            }\n            if (typedResults?.length) {\n                const firstResult = typedResults[0];\n                return pipeResultAsync(this, firstResult.output, config, // Hint: If there is more than one typed result, we use a general\n                // union issue with subissues because the issues could contradict\n                // each other.\n                typedResults.length === 1 ? firstResult.issues : schemaIssue(this, unionAsync, input, config, {\n                    reason: \"union\",\n                    issues: subissues(typedResults)\n                }).issues);\n            }\n            if (untypedResults?.length === 1) {\n                return untypedResults[0];\n            }\n            return schemaIssue(this, unionAsync, input, config, {\n                issues: subissues(untypedResults)\n            });\n        }\n    };\n}\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n    return {\n        type: \"unknown\",\n        expects: \"unknown\",\n        async: false,\n        pipe,\n        _parse (input, config) {\n            return pipeResult(this, input, config);\n        }\n    };\n}\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n    return {\n        type: \"unknown\",\n        expects: \"unknown\",\n        async: true,\n        pipe,\n        async _parse (input, config) {\n            return pipeResultAsync(this, input, config);\n        }\n    };\n}\n// src/schemas/variant/variant.ts\nfunction variant(key, options, arg3, arg4) {\n    const [message, pipe] = defaultArgs(arg3, arg4);\n    let cachedExpectedKey;\n    return {\n        type: \"variant\",\n        expects: \"Object\",\n        async: false,\n        key,\n        options,\n        message,\n        pipe,\n        _parse (input, config) {\n            if (input && typeof input === \"object\") {\n                if (this.key in input || !cachedExpectedKey) {\n                    let expectedKey;\n                    let variantResult;\n                    const parseOptions = (options2)=>{\n                        for (const schema of options2){\n                            if (schema.type === \"object\") {\n                                const keySchema = schema.entries[this.key];\n                                const keyResult = keySchema._parse(input[this.key], config);\n                                if (!cachedExpectedKey) {\n                                    expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [\n                                        keySchema.expects\n                                    ];\n                                }\n                                if (!keyResult.issues) {\n                                    const dataResult = schema._parse(input, config);\n                                    if (!dataResult.issues) {\n                                        variantResult = dataResult;\n                                        break;\n                                    }\n                                    if (!variantResult || !variantResult.typed && dataResult.typed) {\n                                        variantResult = dataResult;\n                                    }\n                                }\n                            } else if (schema.type === \"variant\") {\n                                parseOptions(schema.options);\n                                if (variantResult && !variantResult.issues) {\n                                    break;\n                                }\n                            }\n                        }\n                    };\n                    parseOptions(this.options);\n                    cachedExpectedKey = cachedExpectedKey || [\n                        ...new Set(expectedKey)\n                    ].join(\" | \");\n                    if (variantResult) {\n                        if (variantResult.typed) {\n                            return pipeResult(this, variantResult.output, config, variantResult.issues);\n                        }\n                        return variantResult;\n                    }\n                }\n                const value2 = input[this.key];\n                return schemaIssue(this, variant, value2, config, {\n                    expected: cachedExpectedKey,\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: this.key,\n                            value: value2\n                        }\n                    ]\n                });\n            }\n            return schemaIssue(this, variant, input, config);\n        }\n    };\n}\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, arg3, arg4) {\n    const [message, pipe] = defaultArgs(arg3, arg4);\n    let cachedExpectedKey;\n    return {\n        type: \"variant\",\n        expects: \"Object\",\n        async: true,\n        key,\n        options,\n        message,\n        pipe,\n        async _parse (input, config) {\n            if (input && typeof input === \"object\") {\n                if (this.key in input || !cachedExpectedKey) {\n                    let expectedKey;\n                    let variantResult;\n                    const parseOptions = async (options2)=>{\n                        for (const schema of options2){\n                            if (schema.type === \"object\") {\n                                const keySchema = schema.entries[this.key];\n                                const keyResult = await keySchema._parse(input[this.key], config);\n                                if (!cachedExpectedKey) {\n                                    expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [\n                                        keySchema.expects\n                                    ];\n                                }\n                                if (!keyResult.issues) {\n                                    const dataResult = await schema._parse(input, config);\n                                    if (!dataResult.issues) {\n                                        variantResult = dataResult;\n                                        break;\n                                    }\n                                    if (!variantResult || !variantResult.typed && dataResult.typed) {\n                                        variantResult = dataResult;\n                                    }\n                                }\n                            } else if (schema.type === \"variant\") {\n                                await parseOptions(schema.options);\n                                if (variantResult && !variantResult.issues) {\n                                    break;\n                                }\n                            }\n                        }\n                    };\n                    await parseOptions(this.options);\n                    cachedExpectedKey = cachedExpectedKey || [\n                        ...new Set(expectedKey)\n                    ].join(\" | \");\n                    if (variantResult) {\n                        if (variantResult.typed) {\n                            return pipeResultAsync(this, variantResult.output, config, variantResult.issues);\n                        }\n                        return variantResult;\n                    }\n                }\n                const value2 = input[this.key];\n                return schemaIssue(this, variantAsync, value2, config, {\n                    expected: cachedExpectedKey,\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: this.key,\n                            value: value2\n                        }\n                    ]\n                });\n            }\n            return schemaIssue(this, variantAsync, input, config);\n        }\n    };\n}\n// src/schemas/void/void.ts\nfunction void_(message) {\n    return {\n        type: \"void\",\n        expects: \"void\",\n        async: false,\n        message,\n        _parse (input, config) {\n            if (input === void 0) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, void_, input, config);\n        }\n    };\n}\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message) {\n    return {\n        type: \"void\",\n        expects: \"void\",\n        async: true,\n        message,\n        async _parse (input, config) {\n            if (input === void 0) {\n                return schemaResult(true, input);\n            }\n            return schemaIssue(this, voidAsync, input, config);\n        }\n    };\n}\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n    return picklist(Object.keys(schema.entries));\n}\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return object(schemas.reduce((entries, schema)=>({\n            ...entries,\n            ...schema.entries\n        }), {}), rest, message, pipe);\n}\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return objectAsync(schemas.reduce((entries, schema)=>({\n            ...entries,\n            ...schema.entries\n        }), {}), rest, message, pipe);\n}\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n    return object(Object.entries(schema.entries).reduce((entries, [key, schema2])=>keys.includes(key) ? entries : {\n            ...entries,\n            [key]: schema2\n        }, {}), rest, message, pipe);\n}\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n    return objectAsync(Object.entries(schema.entries).reduce((entries, [key, schema2])=>keys.includes(key) ? entries : {\n            ...entries,\n            [key]: schema2\n        }, {}), rest, message, pipe);\n}\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config) {\n    const result = schema._parse(input, getGlobalConfig(config));\n    if (result.issues) {\n        throw new ValiError(result.issues);\n    }\n    return result.output;\n}\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config) {\n    const result = await schema._parse(input, getGlobalConfig(config));\n    if (result.issues) {\n        throw new ValiError(result.issues);\n    }\n    return result.output;\n}\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return object(Object.entries(schema.entries).reduce((entries, [key, schema2])=>({\n            ...entries,\n            [key]: optional(schema2)\n        }), {}), rest, message, pipe);\n}\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return objectAsync(Object.entries(schema.entries).reduce((entries, [key, schema2])=>({\n            ...entries,\n            [key]: optionalAsync(schema2)\n        }), {}), rest, message, pipe);\n}\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n    return object(Object.entries(schema.entries).reduce((entries, [key, schema2])=>keys.includes(key) ? {\n            ...entries,\n            [key]: schema2\n        } : entries, {}), rest, message, pipe);\n}\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n    return objectAsync(Object.entries(schema.entries).reduce((entries, [key, schema2])=>keys.includes(key) ? {\n            ...entries,\n            [key]: schema2\n        } : entries, {}), rest, message, pipe);\n}\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return object(Object.entries(schema.entries).reduce((entries, [key, schema2])=>({\n            ...entries,\n            [key]: nonOptional(schema2)\n        }), {}), rest, message, pipe);\n}\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n    const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n    return objectAsync(Object.entries(schema.entries).reduce((entries, [key, schema2])=>({\n            ...entries,\n            [key]: nonOptionalAsync(schema2)\n        }), {}), rest, message, pipe);\n}\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config) {\n    const result = schema._parse(input, getGlobalConfig(config));\n    return {\n        typed: result.typed,\n        success: !result.issues,\n        output: result.output,\n        issues: result.issues\n    };\n}\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config) {\n    const result = await schema._parse(input, getGlobalConfig(config));\n    return {\n        typed: result.typed,\n        success: !result.issues,\n        output: result.output,\n        issues: result.issues\n    };\n}\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n    return {\n        ...schema,\n        _parse (input, config) {\n            const result = schema._parse(input, config);\n            if (result.issues) {\n                result.typed = false;\n            } else {\n                result.output = action(result.output, {\n                    issues: result.issues\n                });\n                if (arg1) {\n                    if (Array.isArray(arg1)) {\n                        return pipeResult({\n                            type: typeof result.output,\n                            pipe: arg1\n                        }, result.output, config);\n                    }\n                    return arg1._parse(result.output, config);\n                }\n            }\n            return result;\n        }\n    };\n}\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n    return {\n        ...schema,\n        async: true,\n        async _parse (input, config) {\n            const result = await schema._parse(input, config);\n            if (result.issues) {\n                result.typed = false;\n            } else {\n                result.output = await action(result.output, {\n                    issues: result.issues\n                });\n                if (arg1) {\n                    if (Array.isArray(arg1)) {\n                        return pipeResultAsync({\n                            type: typeof result.output,\n                            pipe: arg1\n                        }, result.output, config);\n                    }\n                    return arg1._parse(result.output, config);\n                }\n            }\n            return result;\n        }\n    };\n}\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n    return schema.wrapped;\n}\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#([\\da-f]{3}|[\\da-f]{4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n/^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n    return {\n        type: \"to_custom\",\n        async: false,\n        _parse (input) {\n            return actionOutput(action(input));\n        }\n    };\n}\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n    return {\n        type: \"to_custom\",\n        async: true,\n        async _parse (input) {\n            return actionOutput(await action(input));\n        }\n    };\n}\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n    return {\n        type: \"to_lower_case\",\n        async: false,\n        _parse (input) {\n            return actionOutput(input.toLocaleLowerCase());\n        }\n    };\n}\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n    return {\n        type: \"to_max_value\",\n        async: false,\n        requirement,\n        _parse (input) {\n            return actionOutput(input > this.requirement ? this.requirement : input);\n        }\n    };\n}\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n    return {\n        type: \"to_min_value\",\n        async: false,\n        requirement,\n        _parse (input) {\n            return actionOutput(input < this.requirement ? this.requirement : input);\n        }\n    };\n}\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n    return {\n        type: \"to_trimmed\",\n        async: false,\n        _parse (input) {\n            return actionOutput(input.trim());\n        }\n    };\n}\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n    return {\n        type: \"to_trimmed_end\",\n        async: false,\n        _parse (input) {\n            return actionOutput(input.trimEnd());\n        }\n    };\n}\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n    return {\n        type: \"to_trimmed_start\",\n        async: false,\n        _parse (input) {\n            return actionOutput(input.trimStart());\n        }\n    };\n}\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n    return {\n        type: \"to_upper_case\",\n        async: false,\n        _parse (input) {\n            return actionOutput(input.toUpperCase());\n        }\n    };\n}\n// src/validations/bic/bic.ts\nfunction bic(message) {\n    return {\n        type: \"bic\",\n        expects: null,\n        async: false,\n        message,\n        requirement: BIC_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, bic, input, \"BIC\");\n        }\n    };\n}\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message) {\n    return {\n        type: \"bytes\",\n        expects: `${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            const length2 = new TextEncoder().encode(input).length;\n            if (length2 === this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, bytes, input, \"bytes\", `${length2}`);\n        }\n    };\n}\n// src/validations/creditCard/creditCard.ts\nvar SANITIZE_REGEX = /[- ]+/gu;\nvar PROVIDER_REGEX_LIST = [\n    // American Express\n    /^3[47]\\d{13}$/u,\n    // Diners Club\n    /^3(?:0[0-5]|[68]\\d)\\d{11}$/u,\n    // Discover\n    /^6(?:011|5\\d{2})\\d{12,15}$/u,\n    // JCB\n    /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n    // Mastercard\n    /^5[1-5]\\d{2}|(222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n    // UnionPay\n    /^(6[27]\\d{14}|81\\d{14,17})$/u,\n    // Visa\n    /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n    return {\n        type: \"credit_card\",\n        expects: null,\n        async: false,\n        message,\n        requirement: (input)=>{\n            const sanitized = input.replace(SANITIZE_REGEX, \"\");\n            return PROVIDER_REGEX_LIST.some((regex2)=>regex2.test(sanitized)) && isLuhnAlgo(sanitized);\n        },\n        _parse (input) {\n            if (this.requirement(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, creditCard, input, \"credit card\");\n        }\n    };\n}\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message) {\n    return {\n        type: \"cuid2\",\n        expects: null,\n        async: false,\n        message,\n        requirement: CUID2_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, cuid2, input, \"Cuid2\");\n        }\n    };\n}\n// src/validations/custom/custom.ts\nfunction custom(requirement, message) {\n    return {\n        type: \"custom\",\n        expects: null,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (this.requirement(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, custom, input, \"input\");\n        }\n    };\n}\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message) {\n    return {\n        type: \"custom\",\n        expects: null,\n        async: true,\n        message,\n        requirement,\n        async _parse (input) {\n            if (await this.requirement(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, customAsync, input, \"input\");\n        }\n    };\n}\n// src/validations/decimal/decimal.ts\nfunction decimal(message) {\n    return {\n        type: \"decimal\",\n        expects: null,\n        async: false,\n        message,\n        requirement: DECIMAL_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, decimal, input, \"decimal\");\n        }\n    };\n}\n// src/validations/email/email.ts\nfunction email(message) {\n    return {\n        type: \"email\",\n        expects: null,\n        async: false,\n        message,\n        requirement: EMAIL_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, email, input, \"email\");\n        }\n    };\n}\n// src/validations/emoji/emoji.ts\nfunction emoji(message) {\n    return {\n        type: \"emoji\",\n        expects: null,\n        async: false,\n        message,\n        requirement: EMOJI_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, emoji, input, \"emoji\");\n        }\n    };\n}\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n    return {\n        type: \"ends_with\",\n        expects: `\"${requirement}\"`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.endsWith(this.requirement)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, endsWith, input, \"end\", `\"${input.slice(-this.requirement.length)}\"`);\n        }\n    };\n}\n// src/validations/every/every.ts\nfunction every(requirement, message) {\n    return {\n        type: \"every\",\n        expects: null,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.every(this.requirement)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, every, input, \"input\");\n        }\n    };\n}\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message) {\n    const received = stringify(requirement);\n    return {\n        type: \"excludes\",\n        expects: `!${received}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (!input.includes(this.requirement)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, excludes, input, \"content\", received);\n        }\n    };\n}\n// src/validations/finite/finite.ts\nfunction finite(message) {\n    return {\n        type: \"finite\",\n        expects: null,\n        async: false,\n        message,\n        requirement: Number.isFinite,\n        _parse (input) {\n            if (this.requirement(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, finite, input, \"finite\");\n        }\n    };\n}\n// src/validations/hash/hash.ts\nvar HASH_LENGTHS = {\n    md4: 32,\n    md5: 32,\n    sha1: 40,\n    sha256: 64,\n    sha384: 96,\n    sha512: 128,\n    ripemd128: 32,\n    ripemd160: 40,\n    tiger128: 32,\n    tiger160: 40,\n    tiger192: 48,\n    crc32: 8,\n    crc32b: 8,\n    adler32: 8\n};\nfunction hash(types, message) {\n    return {\n        type: \"hash\",\n        expects: null,\n        async: false,\n        message,\n        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, hash, input, \"hash\");\n        }\n    };\n}\n// src/validations/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n    return {\n        type: \"hexadecimal\",\n        expects: null,\n        async: false,\n        message,\n        requirement: HEXADECIMAL_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, hexadecimal, input, \"hexadecimal\");\n        }\n    };\n}\n// src/validations/hexColor/hexColor.ts\nfunction hexColor(message) {\n    return {\n        type: \"hex_color\",\n        expects: null,\n        async: false,\n        message,\n        requirement: HEX_COLOR_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, hexColor, input, \"hex color\");\n        }\n    };\n}\n// src/validations/imei/imei.ts\nfunction imei(message) {\n    return {\n        type: \"imei\",\n        expects: null,\n        async: false,\n        message,\n        requirement: [\n            IMEI_REGEX,\n            isLuhnAlgo\n        ],\n        _parse (input) {\n            if (this.requirement[0].test(input) && this.requirement[1](input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, imei, input, \"IMEI\");\n        }\n    };\n}\n// src/validations/includes/includes.ts\nfunction includes(requirement, message) {\n    const expects = stringify(requirement);\n    return {\n        type: \"includes\",\n        expects,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.includes(this.requirement)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, includes, input, \"content\", `!${expects}`);\n        }\n    };\n}\n// src/validations/integer/integer.ts\nfunction integer(message) {\n    return {\n        type: \"integer\",\n        expects: null,\n        async: false,\n        message,\n        requirement: Number.isInteger,\n        _parse (input) {\n            if (this.requirement(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, integer, input, \"integer\");\n        }\n    };\n}\n// src/validations/ip/ip.ts\nfunction ip(message) {\n    return {\n        type: \"ip\",\n        expects: null,\n        async: false,\n        message,\n        // TODO: It is strange that we have an OR relationship between requirements\n        requirement: [\n            IPV4_REGEX,\n            IPV6_REGEX\n        ],\n        _parse (input) {\n            if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, ip, input, \"IP\");\n        }\n    };\n}\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message) {\n    return {\n        type: \"ipv4\",\n        expects: null,\n        async: false,\n        message,\n        requirement: IPV4_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, ipv4, input, \"IPv4\");\n        }\n    };\n}\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message) {\n    return {\n        type: \"ipv6\",\n        expects: null,\n        async: false,\n        message,\n        requirement: IPV6_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, ipv6, input, \"IPv6\");\n        }\n    };\n}\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message) {\n    return {\n        type: \"iso_date\",\n        expects: null,\n        async: false,\n        message,\n        requirement: ISO_DATE_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, isoDate, input, \"date\");\n        }\n    };\n}\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n    return {\n        type: \"iso_date_time\",\n        expects: null,\n        async: false,\n        message,\n        requirement: ISO_DATE_TIME_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, isoDateTime, input, \"date-time\");\n        }\n    };\n}\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message) {\n    return {\n        type: \"iso_time\",\n        expects: null,\n        async: false,\n        message,\n        requirement: ISO_TIME_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, isoTime, input, \"time\");\n        }\n    };\n}\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n    return {\n        type: \"iso_time_second\",\n        expects: null,\n        async: false,\n        message,\n        requirement: ISO_TIME_SECOND_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, isoTimeSecond, input, \"time second\");\n        }\n    };\n}\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n    return {\n        type: \"iso_timestamp\",\n        expects: null,\n        async: false,\n        message,\n        requirement: ISO_TIMESTAMP_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, isoTimestamp, input, \"timestamp\");\n        }\n    };\n}\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n    return {\n        type: \"iso_week\",\n        expects: null,\n        async: false,\n        message,\n        requirement: ISO_WEEK_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, isoWeek, input, \"week\");\n        }\n    };\n}\n// src/validations/length/length.ts\nfunction length(requirement, message) {\n    return {\n        type: \"length\",\n        expects: `${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.length === this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, length, input, \"length\", `${input.length}`);\n        }\n    };\n}\n// src/validations/mac/mac.ts\nfunction mac(message) {\n    return {\n        type: \"mac\",\n        expects: null,\n        async: false,\n        message,\n        // TODO: It is strange that we have an OR relationship between requirements\n        requirement: [\n            MAC48_REGEX,\n            MAC64_REGEX\n        ],\n        _parse (input) {\n            if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, mac, input, \"MAC\");\n        }\n    };\n}\n// src/validations/mac48/mac48.ts\nfunction mac48(message) {\n    return {\n        type: \"mac48\",\n        expects: null,\n        async: false,\n        message,\n        requirement: MAC48_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, mac48, input, \"48-bit MAC\");\n        }\n    };\n}\n// src/validations/mac64/mac64.ts\nfunction mac64(message) {\n    return {\n        type: \"mac64\",\n        expects: null,\n        async: false,\n        message,\n        requirement: MAC64_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, mac64, input, \"64-bit MAC\");\n        }\n    };\n}\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n    return {\n        type: \"max_bytes\",\n        expects: `<=${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            const length2 = new TextEncoder().encode(input).length;\n            if (length2 <= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, maxBytes, input, \"bytes\", `${length2}`);\n        }\n    };\n}\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n    return {\n        type: \"max_length\",\n        expects: `<=${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.length <= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, maxLength, input, \"length\", `${input.length}`);\n        }\n    };\n}\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n    return {\n        type: \"max_size\",\n        expects: `<=${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.size <= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, maxSize, input, \"size\", `${input.size}`);\n        }\n    };\n}\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n    return {\n        type: \"max_value\",\n        expects: `<=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input <= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, maxValue, input, \"value\", input instanceof Date ? input.toJSON() : stringify(input));\n        }\n    };\n}\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n    return {\n        type: \"min_bytes\",\n        expects: `>=${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            const length2 = new TextEncoder().encode(input).length;\n            if (length2 >= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, minBytes, input, \"bytes\", `${length2}`);\n        }\n    };\n}\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n    return {\n        type: \"mime_type\",\n        expects: requirement.map((option)=>`\"${option}\"`).join(\" | \"),\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (this.requirement.includes(input.type)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, mimeType, input, \"MIME type\");\n        }\n    };\n}\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message) {\n    return {\n        type: \"min_length\",\n        expects: `>=${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.length >= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, minLength, input, \"length\", `${input.length}`);\n        }\n    };\n}\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message) {\n    return {\n        type: \"min_size\",\n        expects: `>=${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.size >= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, minSize, input, \"size\", `${input.size}`);\n        }\n    };\n}\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message) {\n    return {\n        type: \"min_value\",\n        expects: `>=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input >= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, minValue, input, \"value\", input instanceof Date ? input.toJSON() : stringify(input));\n        }\n    };\n}\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n    return {\n        type: \"multiple_of\",\n        expects: `%${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input % this.requirement === 0) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, multipleOf, input, \"multiple\", `${input}`);\n        }\n    };\n}\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n    return {\n        type: \"not_bytes\",\n        expects: `!${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            const length2 = new TextEncoder().encode(input).length;\n            if (length2 !== this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, notBytes, input, \"bytes\", `${length2}`);\n        }\n    };\n}\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message) {\n    return {\n        type: \"not_length\",\n        expects: `!${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.length !== this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, notLength, input, \"length\", `${input.length}`);\n        }\n    };\n}\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message) {\n    return {\n        type: \"not_size\",\n        expects: `!${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.size !== this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, notSize, input, \"size\", `${input.size}`);\n        }\n    };\n}\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message) {\n    return {\n        type: \"not_value\",\n        expects: `!${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input < this.requirement || input > this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, notValue, input, \"value\", input instanceof Date ? input.toJSON() : stringify(input));\n        }\n    };\n}\n// src/validations/octal/octal.ts\nfunction octal(message) {\n    return {\n        type: \"octal\",\n        expects: null,\n        async: false,\n        message,\n        requirement: OCTAL_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, octal, input, \"octal\");\n        }\n    };\n}\n// src/validations/regex/regex.ts\nfunction regex(requirement, message) {\n    return {\n        type: \"regex\",\n        expects: `${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, regex, input, \"format\");\n        }\n    };\n}\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n    return {\n        type: \"safe_integer\",\n        expects: null,\n        async: false,\n        message,\n        requirement: Number.isSafeInteger,\n        _parse (input) {\n            if (this.requirement(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, safeInteger, input, \"safe integer\");\n        }\n    };\n}\n// src/validations/size/size.ts\nfunction size(requirement, message) {\n    return {\n        type: \"size\",\n        expects: `${requirement}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.size === this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, size, input, \"size\", `${input.size}`);\n        }\n    };\n}\n// src/validations/some/some.ts\nfunction some(requirement, message) {\n    return {\n        type: \"some\",\n        expects: null,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.some(this.requirement)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, some, input, \"input\");\n        }\n    };\n}\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n    return {\n        type: \"starts_with\",\n        expects: `\"${requirement}\"`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input.startsWith(this.requirement)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, startsWith, input, \"start\", `\"${input.slice(0, this.requirement.length)}\"`);\n        }\n    };\n}\n// src/validations/ulid/ulid.ts\nfunction ulid(message) {\n    return {\n        type: \"ulid\",\n        expects: null,\n        async: false,\n        message,\n        requirement: ULID_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, ulid, input, \"ULID\");\n        }\n    };\n}\n// src/validations/url/url.ts\nfunction url(message) {\n    return {\n        type: \"url\",\n        expects: null,\n        async: false,\n        message,\n        requirement (input) {\n            try {\n                new URL(input);\n                return true;\n            } catch  {\n                return false;\n            }\n        },\n        _parse (input) {\n            if (this.requirement(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, url, input, \"URL\");\n        }\n    };\n}\n// src/validations/uuid/uuid.ts\nfunction uuid(message) {\n    return {\n        type: \"uuid\",\n        expects: null,\n        async: false,\n        message,\n        requirement: UUID_REGEX,\n        _parse (input) {\n            if (this.requirement.test(input)) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, uuid, input, \"UUID\");\n        }\n    };\n}\n// src/validations/value/value.ts\nfunction value(requirement, message) {\n    return {\n        type: \"value\",\n        expects: `${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n        async: false,\n        message,\n        requirement,\n        _parse (input) {\n            if (input <= this.requirement && input >= this.requirement) {\n                return actionOutput(input);\n            }\n            return actionIssue(this, value, input, \"value\", input instanceof Date ? input.toJSON() : stringify(input));\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsU0FBU0EsUUFBUUMsSUFBSTtJQUNuQixPQUFPLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUUEsT0FBT0EsS0FBS0csTUFBTSxFQUFFQyxNQUFNLENBQ3RELENBQUNDLFlBQVlDO1FBQ1gsSUFBSUEsTUFBTUMsSUFBSSxFQUFFO1lBQ2QsSUFBSUQsTUFBTUMsSUFBSSxDQUFDQyxLQUFLLENBQ2xCLENBQUMsRUFBRUMsR0FBRyxFQUFFLEdBQUssT0FBT0EsUUFBUSxZQUFZLE9BQU9BLFFBQVEsV0FDdEQ7Z0JBQ0QsTUFBTUYsT0FBT0QsTUFBTUMsSUFBSSxDQUFDRyxHQUFHLENBQUMsQ0FBQyxFQUFFRCxHQUFHLEVBQUUsR0FBS0EsS0FBS0UsSUFBSSxDQUFDO2dCQUNuRCxJQUFJTixXQUFXTyxNQUFNLENBQUNMLEtBQUssRUFBRTtvQkFDM0JGLFdBQVdPLE1BQU0sQ0FBQ0wsS0FBSyxDQUFDTSxJQUFJLENBQUNQLE1BQU1RLE9BQU87Z0JBQzVDLE9BQU87b0JBQ0xULFdBQVdPLE1BQU0sQ0FBQ0wsS0FBSyxHQUFHO3dCQUFDRCxNQUFNUSxPQUFPO3FCQUFDO2dCQUMzQztZQUNGO1FBQ0YsT0FBTztZQUNMLElBQUlULFdBQVdVLElBQUksRUFBRTtnQkFDbkJWLFdBQVdVLElBQUksQ0FBQ0YsSUFBSSxDQUFDUCxNQUFNUSxPQUFPO1lBQ3BD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O1FBQ05XLFNBQVMsQ0FBQyxFQUFFQyx1QkFBdUJ5RCxPQUFPekQsWUFBWStSLE1BQU0sS0FBS3ZTLFVBQVVRLGFBQWEsQ0FBQztRQUN6RjBDLE9BQU87UUFDUGxIO1FBQ0F3RTtRQUNBNUQsUUFBT0MsS0FBSztZQUNWLElBQUlBLFNBQVMsSUFBSSxDQUFDMkQsV0FBVyxJQUFJM0QsU0FBUyxJQUFJLENBQUMyRCxXQUFXLEVBQUU7Z0JBQzFELE9BQU9uRCxhQUFhUjtZQUN0QjtZQUNBLE9BQU9HLFlBQ0wsSUFBSSxFQUNKa0YsT0FDQXJGLE9BQ0EsU0FDQUEsaUJBQWlCb0gsT0FBT3BILE1BQU0wVixNQUFNLEtBQUt2UyxVQUFVbkQ7UUFFdkQ7SUFDRjtBQUNGO0FBMk5FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZmlyc3QtZnJvZy8uL25vZGVfbW9kdWxlcy92YWxpYm90L2Rpc3QvaW5kZXguanM/NDhkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3IvZmxhdHRlbi9mbGF0dGVuLnRzXG5mdW5jdGlvbiBmbGF0dGVuKGFyZzEpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZzEpID8gYXJnMSA6IGFyZzEuaXNzdWVzKS5yZWR1Y2UoXG4gICAgKGZsYXRFcnJvcnMsIGlzc3VlKSA9PiB7XG4gICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICBpZiAoaXNzdWUucGF0aC5ldmVyeShcbiAgICAgICAgICAoeyBrZXkgfSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Yga2V5ID09PSBcIm51bWJlclwiXG4gICAgICAgICkpIHtcbiAgICAgICAgICBjb25zdCBwYXRoID0gaXNzdWUucGF0aC5tYXAoKHsga2V5IH0pID0+IGtleSkuam9pbihcIi5cIik7XG4gICAgICAgICAgaWYgKGZsYXRFcnJvcnMubmVzdGVkW3BhdGhdKSB7XG4gICAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtwYXRoXS5wdXNoKGlzc3VlLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtwYXRoXSA9IFtpc3N1ZS5tZXNzYWdlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmbGF0RXJyb3JzLnJvb3QpIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLnJvb3QucHVzaChpc3N1ZS5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLnJvb3QgPSBbaXNzdWUubWVzc2FnZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0RXJyb3JzO1xuICAgIH0sXG4gICAgeyBuZXN0ZWQ6IHt9IH1cbiAgKTtcbn1cblxuLy8gc3JjL2Vycm9yL1ZhbGlFcnJvci9WYWxpRXJyb3IudHNcbnZhciBWYWxpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgaXNzdWVzO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFZhbGlib3QgZXJyb3Igd2l0aCB1c2VmdWwgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpc3N1ZXMgVGhlIGVycm9yIGlzc3Vlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgIHN1cGVyKGlzc3Vlc1swXS5tZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlZhbGlFcnJvclwiO1xuICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICB9XG59O1xuXG4vLyBzcmMvbWV0aG9kcy9icmFuZC9icmFuZC50c1xudmFyIEJyYW5kU3ltYm9sID0gU3ltYm9sKFwiYnJhbmRcIik7XG5mdW5jdGlvbiBicmFuZChzY2hlbWEsIG5hbWUpIHtcbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL21ldGhvZHMvY29lcmNlL2NvZXJjZS50c1xuZnVuY3Rpb24gY29lcmNlKHNjaGVtYSwgYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShhY3Rpb24oaW5wdXQpLCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvY29lcmNlL2NvZXJjZUFzeW5jLnRzXG5mdW5jdGlvbiBjb2VyY2VBc3luYyhzY2hlbWEsIGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UoYXdhaXQgYWN0aW9uKGlucHV0KSwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9hY3Rpb25Jc3N1ZS9hY3Rpb25Jc3N1ZS50c1xuZnVuY3Rpb24gYWN0aW9uSXNzdWUoY29udGV4dCwgcmVmZXJlbmNlLCBpbnB1dCwgbGFiZWwsIHJlY2VpdmVkKSB7XG4gIHJldHVybiB7XG4gICAgaXNzdWVzOiBbeyBjb250ZXh0LCByZWZlcmVuY2UsIGlucHV0LCBsYWJlbCwgcmVjZWl2ZWQgfV1cbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2FjdGlvbk91dHB1dC9hY3Rpb25PdXRwdXQudHNcbmZ1bmN0aW9uIGFjdGlvbk91dHB1dChvdXRwdXQpIHtcbiAgcmV0dXJuIHsgb3V0cHV0IH07XG59XG5cbi8vIHNyYy91dGlscy9kZWZhdWx0QXJncy9kZWZhdWx0QXJncy50c1xuZnVuY3Rpb24gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcxKSA/IFt2b2lkIDAsIGFyZzFdIDogW2FyZzEsIGFyZzJdO1xufVxuXG4vLyBzcmMvc3RvcmFnZXMvZ2xvYmFsQ29uZmlnL2dsb2JhbENvbmZpZy50c1xudmFyIHN0b3JlO1xuZnVuY3Rpb24gc2V0R2xvYmFsQ29uZmlnKGNvbmZpZykge1xuICBzdG9yZSA9IHsgLi4uc3RvcmUsIC4uLmNvbmZpZyB9O1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGxhbmc6IGNvbmZpZz8ubGFuZyA/PyBzdG9yZT8ubGFuZyxcbiAgICBtZXNzYWdlOiBjb25maWc/Lm1lc3NhZ2UsXG4gICAgYWJvcnRFYXJseTogY29uZmlnPy5hYm9ydEVhcmx5ID8/IHN0b3JlPy5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBjb25maWc/LmFib3J0UGlwZUVhcmx5ID8/IHN0b3JlPy5hYm9ydFBpcGVFYXJseSxcbiAgICBza2lwUGlwZTogY29uZmlnPy5za2lwUGlwZSA/PyBzdG9yZT8uc2tpcFBpcGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUdsb2JhbENvbmZpZygpIHtcbiAgc3RvcmUgPSB2b2lkIDA7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9nbG9iYWxNZXNzYWdlL2dsb2JhbE1lc3NhZ2UudHNcbnZhciBzdG9yZTI7XG5mdW5jdGlvbiBzZXRHbG9iYWxNZXNzYWdlKG1lc3NhZ2UsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTIpXG4gICAgc3RvcmUyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmUyLnNldChsYW5nLCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbE1lc3NhZ2UobGFuZykge1xuICByZXR1cm4gc3RvcmUyPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVHbG9iYWxNZXNzYWdlKGxhbmcpIHtcbiAgc3RvcmUyPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9zY2hlbWFNZXNzYWdlL3NjaGVtYU1lc3NhZ2UudHNcbnZhciBzdG9yZTM7XG5mdW5jdGlvbiBzZXRTY2hlbWFNZXNzYWdlKG1lc3NhZ2UsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTMpXG4gICAgc3RvcmUzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmUzLnNldChsYW5nLCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGdldFNjaGVtYU1lc3NhZ2UobGFuZykge1xuICByZXR1cm4gc3RvcmUzPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTY2hlbWFNZXNzYWdlKGxhbmcpIHtcbiAgc3RvcmUzPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9zcGVjaWZpY01lc3NhZ2Uvc3BlY2lmaWNNZXNzYWdlLnRzXG52YXIgc3RvcmU0O1xuZnVuY3Rpb24gc2V0U3BlY2lmaWNNZXNzYWdlKHJlZmVyZW5jZSwgbWVzc2FnZSwgbGFuZykge1xuICBpZiAoIXN0b3JlNClcbiAgICBzdG9yZTQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoIXN0b3JlNC5nZXQocmVmZXJlbmNlKSlcbiAgICBzdG9yZTQuc2V0KHJlZmVyZW5jZSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIHN0b3JlNC5nZXQocmVmZXJlbmNlKS5zZXQobGFuZywgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHJldHVybiBzdG9yZTQ/LmdldChyZWZlcmVuY2UpPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHN0b3JlND8uZ2V0KHJlZmVyZW5jZSk/LmRlbGV0ZShsYW5nKTtcbn1cblxuLy8gc3JjL3V0aWxzL2kxOG4vaTE4bi50c1xuZnVuY3Rpb24gaTE4bihzY2hlbWEsIGNvbnRleHQsIHJlZmVyZW5jZSwgY29uZmlnLCBpc3N1ZSkge1xuICBjb25zdCBtZXNzYWdlID0gY29udGV4dC5tZXNzYWdlID8/IGdldFNwZWNpZmljTWVzc2FnZShyZWZlcmVuY2UsIGlzc3VlLmxhbmcpID8/IChzY2hlbWEgPyBnZXRTY2hlbWFNZXNzYWdlKGlzc3VlLmxhbmcpIDogbnVsbCkgPz8gY29uZmlnPy5tZXNzYWdlID8/IGdldEdsb2JhbE1lc3NhZ2UoaXNzdWUubGFuZykgPz8gaXNzdWUubWVzc2FnZTtcbiAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGlzc3VlKSA6IG1lc3NhZ2U7XG59XG5cbi8vIHNyYy91dGlscy9pc0x1aG5BbGdvL2lzTHVobkFsZ28udHNcbnZhciBOT05fRElHSVRfUkVHRVggPSAvXFxEL2d1O1xuZnVuY3Rpb24gaXNMdWhuQWxnbyhpbnB1dCkge1xuICBjb25zdCBudW1iZXIyID0gaW5wdXQucmVwbGFjZShOT05fRElHSVRfUkVHRVgsIFwiXCIpO1xuICBsZXQgbGVuZ3RoMiA9IG51bWJlcjIubGVuZ3RoO1xuICBsZXQgYml0ID0gMTtcbiAgbGV0IHN1bSA9IDA7XG4gIHdoaWxlIChsZW5ndGgyKSB7XG4gICAgY29uc3QgdmFsdWUyID0gK251bWJlcjJbLS1sZW5ndGgyXTtcbiAgICBiaXQgXj0gMTtcbiAgICBzdW0gKz0gYml0ID8gWzAsIDIsIDQsIDYsIDgsIDEsIDMsIDUsIDcsIDldW3ZhbHVlMl0gOiB2YWx1ZTI7XG4gIH1cbiAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNPZlR5cGUvaXNPZlR5cGUudHNcbmZ1bmN0aW9uIGlzT2ZUeXBlKHR5cGUsIG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIudHlwZSA9PT0gdHlwZTtcbn1cblxuLy8gc3JjL3V0aWxzL3NjaGVtYVJlc3VsdC9zY2hlbWFSZXN1bHQudHNcbmZ1bmN0aW9uIHNjaGVtYVJlc3VsdCh0eXBlZCwgb3V0cHV0LCBpc3N1ZXMpIHtcbiAgcmV0dXJuIHsgdHlwZWQsIG91dHB1dCwgaXNzdWVzIH07XG59XG5cbi8vIHNyYy91dGlscy9zdHJpbmdpZnkvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkoaW5wdXQpIHtcbiAgbGV0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgdHlwZSA9IGlucHV0ID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KS5jb25zdHJ1Y3Rvci5uYW1lIDogXCJudWxsXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgPyBgXCIke2lucHV0fVwiYCA6IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiA/IGAke2lucHV0fWAgOiB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvcGlwZVJlc3VsdC91dGlscy9waXBlSXNzdWUvcGlwZUlzc3VlLnRzXG5mdW5jdGlvbiBwaXBlSXNzdWUoY29udGV4dCwgY29uZmlnLCBpc3N1ZSkge1xuICBjb25zdCByZWNlaXZlZCA9IGlzc3VlLnJlY2VpdmVkID8/IHN0cmluZ2lmeShpc3N1ZS5pbnB1dCk7XG4gIGNvbnN0IHNjaGVtYUlzc3VlMiA9IHtcbiAgICByZWFzb246IGNvbnRleHQudHlwZSxcbiAgICBjb250ZXh0OiBpc3N1ZS5jb250ZXh0LnR5cGUsXG4gICAgZXhwZWN0ZWQ6IGlzc3VlLmNvbnRleHQuZXhwZWN0cyxcbiAgICByZWNlaXZlZCxcbiAgICBtZXNzYWdlOiBgSW52YWxpZCAke2lzc3VlLmxhYmVsfTogJHtpc3N1ZS5jb250ZXh0LmV4cGVjdHMgPyBgRXhwZWN0ZWQgJHtpc3N1ZS5jb250ZXh0LmV4cGVjdHN9IGJ1dCByYCA6IFwiUlwifWVjZWl2ZWQgJHtyZWNlaXZlZH1gLFxuICAgIGlucHV0OiBpc3N1ZS5pbnB1dCxcbiAgICByZXF1aXJlbWVudDogaXNzdWUuY29udGV4dC5yZXF1aXJlbWVudCxcbiAgICBwYXRoOiBpc3N1ZS5wYXRoLFxuICAgIGxhbmc6IGNvbmZpZz8ubGFuZyxcbiAgICBhYm9ydEVhcmx5OiBjb25maWc/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGNvbmZpZz8uYWJvcnRQaXBlRWFybHksXG4gICAgc2tpcFBpcGU6IGNvbmZpZz8uc2tpcFBpcGVcbiAgfTtcbiAgc2NoZW1hSXNzdWUyLm1lc3NhZ2UgPSBpMThuKFxuICAgIGZhbHNlLFxuICAgIGlzc3VlLmNvbnRleHQsXG4gICAgaXNzdWUucmVmZXJlbmNlLFxuICAgIGNvbmZpZyxcbiAgICBzY2hlbWFJc3N1ZTJcbiAgKTtcbiAgcmV0dXJuIHNjaGVtYUlzc3VlMjtcbn1cblxuLy8gc3JjL3V0aWxzL3BpcGVSZXN1bHQvcGlwZVJlc3VsdC50c1xuZnVuY3Rpb24gcGlwZVJlc3VsdChjb250ZXh0LCBpbnB1dCwgY29uZmlnLCBpc3N1ZXMpIHtcbiAgaWYgKGNvbnRleHQucGlwZSAmJiAhY29uZmlnPy5za2lwUGlwZSkge1xuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGNvbnRleHQucGlwZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLl9wYXJzZShpbnB1dCk7XG4gICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbklzc3VlMiBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgY29uc3Qgc2NoZW1hSXNzdWUyID0gcGlwZUlzc3VlKGNvbnRleHQsIGNvbmZpZywgYWN0aW9uSXNzdWUyKTtcbiAgICAgICAgICBpc3N1ZXMgPyBpc3N1ZXMucHVzaChzY2hlbWFJc3N1ZTIpIDogaXNzdWVzID0gW3NjaGVtYUlzc3VlMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSB8fCBjb25maWc/LmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0ID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCwgaXNzdWVzKTtcbn1cblxuLy8gc3JjL3V0aWxzL3BpcGVSZXN1bHQvcGlwZVJlc3VsdEFzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBwaXBlUmVzdWx0QXN5bmMoY29udGV4dCwgaW5wdXQsIGNvbmZpZywgaXNzdWVzKSB7XG4gIGlmIChjb250ZXh0LnBpcGUgJiYgIWNvbmZpZz8uc2tpcFBpcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBjb250ZXh0LnBpcGUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbi5fcGFyc2UoaW5wdXQpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25Jc3N1ZTIgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYUlzc3VlMiA9IHBpcGVJc3N1ZShjb250ZXh0LCBjb25maWcsIGFjdGlvbklzc3VlMik7XG4gICAgICAgICAgaXNzdWVzID8gaXNzdWVzLnB1c2goc2NoZW1hSXNzdWUyKSA6IGlzc3VlcyA9IFtzY2hlbWFJc3N1ZTJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkgfHwgY29uZmlnPy5hYm9ydFBpcGVFYXJseSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dCA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQsIGlzc3Vlcyk7XG59XG5cbi8vIHNyYy91dGlscy9yZXN0QW5kRGVmYXVsdEFyZ3MvcmVzdEFuZERlZmF1bHRBcmdzLnRzXG5mdW5jdGlvbiByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoIWFyZzEgfHwgdHlwZW9mIGFyZzEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICBjb25zdCBbZXJyb3IyLCBwaXBlMl0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgICByZXR1cm4gW2FyZzEsIGVycm9yMiwgcGlwZTJdO1xuICB9XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBkZWZhdWx0QXJncyhcbiAgICBhcmcxLFxuICAgIGFyZzJcbiAgKTtcbiAgcmV0dXJuIFt2b2lkIDAsIGVycm9yLCBwaXBlXTtcbn1cblxuLy8gc3JjL3V0aWxzL3NjaGVtYUlzc3VlL3NjaGVtYUlzc3VlLnRzXG5mdW5jdGlvbiBzY2hlbWFJc3N1ZShjb250ZXh0LCByZWZlcmVuY2UsIGlucHV0LCBjb25maWcsIG90aGVyKSB7XG4gIGNvbnN0IHJlY2VpdmVkID0gc3RyaW5naWZ5KGlucHV0KTtcbiAgY29uc3QgZXhwZWN0ZWQgPSBvdGhlcj8uZXhwZWN0ZWQgPz8gY29udGV4dC5leHBlY3RzO1xuICBjb25zdCBpc3N1ZSA9IHtcbiAgICByZWFzb246IG90aGVyPy5yZWFzb24gPz8gXCJ0eXBlXCIsXG4gICAgY29udGV4dDogY29udGV4dC50eXBlLFxuICAgIGV4cGVjdGVkLFxuICAgIHJlY2VpdmVkLFxuICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHR5cGU6IEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGJ1dCByZWNlaXZlZCAke3JlY2VpdmVkfWAsXG4gICAgaW5wdXQsXG4gICAgcGF0aDogb3RoZXI/LnBhdGgsXG4gICAgaXNzdWVzOiBvdGhlcj8uaXNzdWVzLFxuICAgIGxhbmc6IGNvbmZpZz8ubGFuZyxcbiAgICBhYm9ydEVhcmx5OiBjb25maWc/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGNvbmZpZz8uYWJvcnRQaXBlRWFybHksXG4gICAgc2tpcFBpcGU6IGNvbmZpZz8uc2tpcFBpcGVcbiAgfTtcbiAgaXNzdWUubWVzc2FnZSA9IGkxOG4odHJ1ZSwgY29udGV4dCwgcmVmZXJlbmNlLCBjb25maWcsIGlzc3VlKTtcbiAgcmV0dXJuIHsgdHlwZWQ6IGZhbHNlLCBvdXRwdXQ6IGlucHV0LCBpc3N1ZXM6IFtpc3N1ZV0gfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RmFsbGJhY2svZ2V0RmFsbGJhY2sudHNcbmZ1bmN0aW9uIGdldEZhbGxiYWNrKHNjaGVtYSwgaW5mbykge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5mYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gc2NoZW1hLmZhbGxiYWNrKGluZm8pIDogc2NoZW1hLmZhbGxiYWNrO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFjay9nZXRGYWxsYmFja0FzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRGYWxsYmFja0FzeW5jKHNjaGVtYSwgaW5mbykge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5mYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gYXdhaXQgc2NoZW1hLmZhbGxiYWNrKGluZm8pIDogc2NoZW1hLmZhbGxiYWNrO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFjay50c1xuZnVuY3Rpb24gZmFsbGJhY2soc2NoZW1hLCBmYWxsYmFjazIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZmFsbGJhY2s6IGZhbGxiYWNrMixcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgIHJldHVybiByZXN1bHQuaXNzdWVzID8gc2NoZW1hUmVzdWx0KFxuICAgICAgICB0cnVlLFxuICAgICAgICBnZXRGYWxsYmFjayh0aGlzLCB7IGlucHV0LCBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMgfSlcbiAgICAgICkgOiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFja0FzeW5jLnRzXG5mdW5jdGlvbiBmYWxsYmFja0FzeW5jKHNjaGVtYSwgZmFsbGJhY2syKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGZhbGxiYWNrOiBmYWxsYmFjazIsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmlzc3VlcyA/IHNjaGVtYVJlc3VsdChcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgYXdhaXQgZ2V0RmFsbGJhY2tBc3luYyh0aGlzLCB7IGlucHV0LCBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMgfSlcbiAgICAgICkgOiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mb3J3YXJkL2ZvcndhcmQudHNcbmZ1bmN0aW9uIGZvcndhcmQodmFsaWRhdGlvbiwgcGF0aExpc3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi52YWxpZGF0aW9uLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGlvbi5fcGFyc2UoaW5wdXQpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgbGV0IHBhdGhJbnB1dCA9IGlucHV0O1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhdGhMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoVmFsdWUgPSBwYXRoSW5wdXRba2V5XTtcbiAgICAgICAgICAgIGlzc3VlLmlucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQ6IHBhdGhJbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXNzdWUucGF0aCA/IGlzc3VlLnBhdGgucHVzaChwYXRoSXRlbSkgOiBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZvcndhcmQvZm9yd2FyZEFzeW5jLnRzXG5mdW5jdGlvbiBmb3J3YXJkQXN5bmModmFsaWRhdGlvbiwgcGF0aExpc3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi52YWxpZGF0aW9uLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGlvbi5fcGFyc2UoaW5wdXQpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgbGV0IHBhdGhJbnB1dCA9IGlucHV0O1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhdGhMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoVmFsdWUgPSBwYXRoSW5wdXRba2V5XTtcbiAgICAgICAgICAgIGlzc3VlLmlucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQ6IHBhdGhJbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXNzdWUucGF0aCA/IGlzc3VlLnBhdGgucHVzaChwYXRoSXRlbSkgOiBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHQvZ2V0RGVmYXVsdC50c1xuZnVuY3Rpb24gZ2V0RGVmYXVsdChzY2hlbWEpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gc2NoZW1hLmRlZmF1bHQoKSA6IHNjaGVtYS5kZWZhdWx0O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0L2dldERlZmF1bHRBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdEFzeW5jKHNjaGVtYSkge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCBzY2hlbWEuZGVmYXVsdCgpIDogc2NoZW1hLmRlZmF1bHQ7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHRzL2dldERlZmF1bHRzLnRzXG5mdW5jdGlvbiBnZXREZWZhdWx0cyhzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdChzY2hlbWEpO1xuICB9XG4gIGlmIChpc09mVHlwZShcIm9iamVjdFwiLCBzY2hlbWEpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAga2V5LFxuICAgICAgICBnZXREZWZhdWx0cyh2YWx1ZTIpXG4gICAgICBdKVxuICAgICk7XG4gIH1cbiAgaWYgKGlzT2ZUeXBlKFwidHVwbGVcIiwgc2NoZW1hKSkge1xuICAgIHJldHVybiBzY2hlbWEuaXRlbXMubWFwKGdldERlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0cy9nZXREZWZhdWx0c0FzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0c0FzeW5jKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBnZXREZWZhdWx0QXN5bmMoc2NoZW1hKTtcbiAgfVxuICBpZiAoaXNPZlR5cGUoXCJvYmplY3RcIiwgc2NoZW1hKSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBhd2FpdCBnZXREZWZhdWx0c0FzeW5jKHZhbHVlMilcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGlmIChpc09mVHlwZShcInR1cGxlXCIsIHNjaGVtYSkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzY2hlbWEuaXRlbXMubWFwKGdldERlZmF1bHRzQXN5bmMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFja3MvZ2V0RmFsbGJhY2tzLnRzXG5mdW5jdGlvbiBnZXRGYWxsYmFja3Moc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBnZXRGYWxsYmFjayhzY2hlbWEpO1xuICB9XG4gIGlmIChpc09mVHlwZShcIm9iamVjdFwiLCBzY2hlbWEpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAga2V5LFxuICAgICAgICBnZXRGYWxsYmFja3ModmFsdWUyKVxuICAgICAgXSlcbiAgICApO1xuICB9XG4gIGlmIChpc09mVHlwZShcInR1cGxlXCIsIHNjaGVtYSkpIHtcbiAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcChnZXRGYWxsYmFja3MpO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrcy9nZXRGYWxsYmFja3NBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmFsbGJhY2tzQXN5bmMoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBnZXRGYWxsYmFja0FzeW5jKHNjaGVtYSk7XG4gIH1cbiAgaWYgKGlzT2ZUeXBlKFwib2JqZWN0XCIsIHNjaGVtYSkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXdhaXQgZ2V0RmFsbGJhY2tzQXN5bmModmFsdWUyKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgaWYgKGlzT2ZUeXBlKFwidHVwbGVcIiwgc2NoZW1hKSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHNjaGVtYS5pdGVtcy5tYXAoZ2V0RmFsbGJhY2tzQXN5bmMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9pcy9pcy50c1xuZnVuY3Rpb24gaXMoc2NoZW1hLCBpbnB1dCwgY29uZmlnKSB7XG4gIHJldHVybiAhc2NoZW1hLl9wYXJzZShpbnB1dCwge1xuICAgIGFib3J0RWFybHk6IHRydWUsXG4gICAgc2tpcFBpcGU6IGdldEdsb2JhbENvbmZpZyhjb25maWcpPy5za2lwUGlwZVxuICB9KS5pc3N1ZXM7XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FueS9hbnkudHNcbmZ1bmN0aW9uIGFueShwaXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhbnlcIixcbiAgICBleHBlY3RzOiBcImFueVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FueS9hbnlBc3luYy50c1xuZnVuY3Rpb24gYW55QXN5bmMocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYW55XCIsXG4gICAgZXhwZWN0czogXCJhbnlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYXJyYXkvYXJyYXkudHNcbmZ1bmN0aW9uIGFycmF5KGl0ZW0sIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgaXNzdWVzO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBvdXRwdXQsIGNvbmZpZywgaXNzdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgYXJyYXksIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYXJyYXkvYXJyYXlBc3luYy50c1xuZnVuY3Rpb24gYXJyYXlBc3luYyhpdGVtLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgaXNzdWVzO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgaW5wdXQubWFwKGFzeW5jICh2YWx1ZTIsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pdGVtLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaXNzdWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgYXJyYXlBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9iaWdpbnQvYmlnaW50LnRzXG5mdW5jdGlvbiBiaWdpbnQoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgIGV4cGVjdHM6IFwiYmlnaW50XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBiaWdpbnQsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmlnaW50L2JpZ2ludEFzeW5jLnRzXG5mdW5jdGlvbiBiaWdpbnRBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgZXhwZWN0czogXCJiaWdpbnRcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBiaWdpbnRBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ibG9iL2Jsb2IudHNcbmZ1bmN0aW9uIGJsb2IoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJsb2JcIixcbiAgICBleHBlY3RzOiBcIkJsb2JcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0KHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGJsb2IsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmxvYi9ibG9iQXN5bmMudHNcbmZ1bmN0aW9uIGJsb2JBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgIGV4cGVjdHM6IFwiQmxvYlwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGJsb2JBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ib29sZWFuL2Jvb2xlYW4udHNcbmZ1bmN0aW9uIGJvb2xlYW4oYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBleHBlY3RzOiBcImJvb2xlYW5cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBib29sZWFuLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Jvb2xlYW4vYm9vbGVhbkFzeW5jLnRzXG5mdW5jdGlvbiBib29sZWFuQXN5bmMoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBleHBlY3RzOiBcImJvb2xlYW5cIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgYm9vbGVhbkFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2RhdGUvZGF0ZS50c1xuZnVuY3Rpb24gZGF0ZShhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgIGV4cGVjdHM6IFwiRGF0ZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKGlucHV0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQodGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgZGF0ZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9kYXRlL2RhdGVBc3luYy50c1xuZnVuY3Rpb24gZGF0ZUFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJkYXRlXCIsXG4gICAgZXhwZWN0czogXCJEYXRlXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihpbnB1dC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgZGF0ZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2VudW0vZW51bS50c1xuZnVuY3Rpb24gZW51bV8oZW51bV9fLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW51bV9fKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBleHBlY3RzOiB2YWx1ZXMubWFwKHN0cmluZ2lmeSkuam9pbihcIiB8IFwiKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW51bTogZW51bV9fLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh2YWx1ZXMuaW5jbHVkZXMoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGVudW1fLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2VudW0vZW51bUFzeW5jLnRzXG5mdW5jdGlvbiBlbnVtQXN5bmMoZW51bV8yLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW51bV8yKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBleHBlY3RzOiB2YWx1ZXMubWFwKHN0cmluZ2lmeSkuam9pbihcIiB8IFwiKSxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnVtOiBlbnVtXzIsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHZhbHVlcy5pbmNsdWRlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgZW51bUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2luc3RhbmNlL2luc3RhbmNlLnRzXG5mdW5jdGlvbiBpbnN0YW5jZShjbGFzc18sIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbnN0YW5jZVwiLFxuICAgIGV4cGVjdHM6IGNsYXNzXy5uYW1lLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBjbGFzczogY2xhc3NfLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgdGhpcy5jbGFzcykge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBpbnN0YW5jZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9pbnN0YW5jZS9pbnN0YW5jZUFzeW5jLnRzXG5mdW5jdGlvbiBpbnN0YW5jZUFzeW5jKGNsYXNzXywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImluc3RhbmNlXCIsXG4gICAgZXhwZWN0czogY2xhc3NfLm5hbWUsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgY2xhc3M6IGNsYXNzXyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIHRoaXMuY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBpbnN0YW5jZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC91dGlscy9tZXJnZU91dHB1dHMvbWVyZ2VPdXRwdXRzLnRzXG5mdW5jdGlvbiBtZXJnZU91dHB1dHMob3V0cHV0MSwgb3V0cHV0Mikge1xuICBpZiAodHlwZW9mIG91dHB1dDEgPT09IHR5cGVvZiBvdXRwdXQyKSB7XG4gICAgaWYgKG91dHB1dDEgPT09IG91dHB1dDIgfHwgb3V0cHV0MSBpbnN0YW5jZW9mIERhdGUgJiYgb3V0cHV0MiBpbnN0YW5jZW9mIERhdGUgJiYgK291dHB1dDEgPT09ICtvdXRwdXQyKSB7XG4gICAgICByZXR1cm4geyBvdXRwdXQ6IG91dHB1dDEgfTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0MSkgJiYgQXJyYXkuaXNBcnJheShvdXRwdXQyKSkge1xuICAgICAgaWYgKG91dHB1dDEubGVuZ3RoID09PSBvdXRwdXQyLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBhcnJheTIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG91dHB1dDEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VPdXRwdXRzKG91dHB1dDFbaW5kZXhdLCBvdXRwdXQyW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcnJheTIucHVzaChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBvdXRwdXQ6IGFycmF5MiB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgaW52YWxpZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAob3V0cHV0MSAmJiBvdXRwdXQyICYmIG91dHB1dDEuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBvdXRwdXQyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGNvbnN0IG9iamVjdDIgPSB7IC4uLm91dHB1dDEsIC4uLm91dHB1dDIgfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG91dHB1dDEpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvdXRwdXQyKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VPdXRwdXRzKG91dHB1dDFba2V5XSwgb3V0cHV0MltrZXldKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmludmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdDJba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogb2JqZWN0MiB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBpbnZhbGlkOiB0cnVlIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC9pbnRlcnNlY3QudHNcbmZ1bmN0aW9uIGludGVyc2VjdChvcHRpb25zLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW50ZXJzZWN0XCIsXG4gICAgZXhwZWN0czogWy4uLm5ldyBTZXQob3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmV4cGVjdHMpKV0uam9pbihcIiAmIFwiKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGlmIChpc3N1ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dHMucHVzaChyZXN1bHQub3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgb3V0cHV0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtZXJnZU91dHB1dHMob3V0cHV0LCBvdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgaW50ZXJzZWN0LCBpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0ID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBvdXRwdXQsIGNvbmZpZywgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC9pbnRlcnNlY3RBc3luYy50c1xuZnVuY3Rpb24gaW50ZXJzZWN0QXN5bmMob3B0aW9ucywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImludGVyc2VjdFwiLFxuICAgIGV4cGVjdHM6IFsuLi5uZXcgU2V0KG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSldLmpvaW4oXCIgJiBcIiksXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICB0aGlzLm9wdGlvbnMubWFwKGFzeW5jIChzY2hlbWEpID0+IHtcbiAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocmVzdWx0Lm91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgb3V0cHV0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtZXJnZU91dHB1dHMob3V0cHV0LCBvdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgaW50ZXJzZWN0QXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQgPSByZXN1bHQub3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgb3V0cHV0LCBjb25maWcsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sYXp5L2xhenkudHNcbmZ1bmN0aW9uIGxhenkoZ2V0dGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJsYXp5XCIsXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldHRlcixcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKGlucHV0KS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sYXp5L2xhenlBc3luYy50c1xuZnVuY3Rpb24gbGF6eUFzeW5jKGdldHRlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGF6eVwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGdldHRlcixcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldHRlcihpbnB1dCkpLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xpdGVyYWwvbGl0ZXJhbC50c1xuZnVuY3Rpb24gbGl0ZXJhbChsaXRlcmFsXywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIGV4cGVjdHM6IHN0cmluZ2lmeShsaXRlcmFsXyksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxfLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGxpdGVyYWwsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbGl0ZXJhbC9saXRlcmFsQXN5bmMudHNcbmZ1bmN0aW9uIGxpdGVyYWxBc3luYyhsaXRlcmFsMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIGV4cGVjdHM6IHN0cmluZ2lmeShsaXRlcmFsMiksXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbDIsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbGl0ZXJhbEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXAudHNcbmZ1bmN0aW9uIG1hcChrZXksIHZhbHVlMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1hcFwiLFxuICAgIGV4cGVjdHM6IFwiTWFwXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0S2V5LCBpbnB1dFZhbHVlXSBvZiBpbnB1dC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBsZXQgcGF0aEl0ZW07XG4gICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0gdGhpcy5rZXkuX3BhcnNlKGlucHV0S2V5LCBjb25maWcpO1xuICAgICAgICAgIGlmIChrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGtleVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMgPSBrZXlSZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWVSZXN1bHQgPSB0aGlzLnZhbHVlLl9wYXJzZShpbnB1dFZhbHVlLCBjb25maWcpO1xuICAgICAgICAgIGlmICh2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gPz8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMgPSB2YWx1ZVJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleVJlc3VsdC50eXBlZCB8fCAhdmFsdWVSZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5zZXQoa2V5UmVzdWx0Lm91dHB1dCwgdmFsdWVSZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBvdXRwdXQsIGNvbmZpZywgaXNzdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbWFwLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXBBc3luYy50c1xuZnVuY3Rpb24gbWFwQXN5bmMoa2V5LCB2YWx1ZTIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtYXBcIixcbiAgICBleHBlY3RzOiBcIk1hcFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIEFycmF5LmZyb20oaW5wdXQuZW50cmllcygpKS5tYXAoYXN5bmMgKFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGxldCBwYXRoSXRlbTtcbiAgICAgICAgICAgIGNvbnN0IFtrZXlSZXN1bHQsIHZhbHVlUmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgeyBzY2hlbWE6IHRoaXMua2V5LCB2YWx1ZTogaW5wdXRLZXksIG9yaWdpbjogXCJrZXlcIiB9LFxuICAgICAgICAgICAgICAgIHsgc2NoZW1hOiB0aGlzLnZhbHVlLCB2YWx1ZTogaW5wdXRWYWx1ZSwgb3JpZ2luOiBcInZhbHVlXCIgfVxuICAgICAgICAgICAgICBdLm1hcChhc3luYyAoeyBzY2hlbWEsIHZhbHVlOiB2YWx1ZTMsIG9yaWdpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UodmFsdWUzLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoSXRlbSA9IHBhdGhJdGVtID8/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLmNhdGNoKCgpID0+IFtdKTtcbiAgICAgICAgICAgIGlmICgha2V5UmVzdWx0Py50eXBlZCB8fCAhdmFsdWVSZXN1bHQ/LnR5cGVkKSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5UmVzdWx0ICYmIHZhbHVlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIG91dHB1dC5zZXQoa2V5UmVzdWx0Lm91dHB1dCwgdmFsdWVSZXN1bHQub3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKHRoaXMsIG91dHB1dCwgY29uZmlnLCBpc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBtYXBBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uYW4vbmFuLnRzXG5mdW5jdGlvbiBuYW4obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmFuXCIsXG4gICAgZXhwZWN0czogXCJOYU5cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbmFuLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25hbi9uYW5Bc3luYy50c1xuZnVuY3Rpb24gbmFuQXN5bmMobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmFuXCIsXG4gICAgZXhwZWN0czogXCJOYU5cIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBuYW5Bc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uZXZlci9uZXZlci50c1xuZnVuY3Rpb24gbmV2ZXIobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICBleHBlY3RzOiBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBuZXZlciwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uZXZlci9uZXZlckFzeW5jLnRzXG5mdW5jdGlvbiBuZXZlckFzeW5jKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5ldmVyXCIsXG4gICAgZXhwZWN0czogXCJuZXZlclwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBuZXZlckFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxhYmxlL25vbk51bGxhYmxlLnRzXG5mdW5jdGlvbiBub25OdWxsYWJsZSh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICBleHBlY3RzOiBcIiFudWxsXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBub25OdWxsYWJsZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxhYmxlL25vbk51bGxhYmxlQXN5bmMudHNcbmZ1bmN0aW9uIG5vbk51bGxhYmxlQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm9uX251bGxhYmxlXCIsXG4gICAgZXhwZWN0czogXCIhbnVsbFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBub25OdWxsYWJsZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGlzaC9ub25OdWxsaXNoLnRzXG5mdW5jdGlvbiBub25OdWxsaXNoKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vbl9udWxsaXNoXCIsXG4gICAgZXhwZWN0czogXCIhbnVsbCAmICF1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbm9uTnVsbGlzaCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaEFzeW5jLnRzXG5mdW5jdGlvbiBub25OdWxsaXNoQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm9uX251bGxpc2hcIixcbiAgICBleHBlY3RzOiBcIiFudWxsICYgIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG5vbk51bGxpc2hBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk9wdGlvbmFsL25vbk9wdGlvbmFsLnRzXG5mdW5jdGlvbiBub25PcHRpb25hbCh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub25fb3B0aW9uYWxcIixcbiAgICBleHBlY3RzOiBcIiF1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbm9uT3B0aW9uYWwsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25PcHRpb25hbC9ub25PcHRpb25hbEFzeW5jLnRzXG5mdW5jdGlvbiBub25PcHRpb25hbEFzeW5jKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vbl9vcHRpb25hbFwiLFxuICAgIGV4cGVjdHM6IFwiIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG5vbk9wdGlvbmFsQXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsYWJsZS9udWxsYWJsZS50c1xuZnVuY3Rpb24gbnVsbGFibGUod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGxgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBnZXREZWZhdWx0KHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlQXN5bmMudHNcbmZ1bmN0aW9uIG51bGxhYmxlQXN5bmMod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGxgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvdmVycmlkZSA9IGF3YWl0IGdldERlZmF1bHRBc3luYyh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2gudHNcbmZ1bmN0aW9uIG51bGxpc2god3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bGxpc2hcIixcbiAgICBleHBlY3RzOiBgJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbCB8IHVuZGVmaW5lZGAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gZ2V0RGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2hBc3luYy50c1xuZnVuY3Rpb24gbnVsbGlzaEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudWxsaXNoXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGwgfCB1bmRlZmluZWRgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gYXdhaXQgZ2V0RGVmYXVsdEFzeW5jKHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGwvbnVsbC50c1xuZnVuY3Rpb24gbnVsbF8obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbFwiLFxuICAgIGV4cGVjdHM6IFwibnVsbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbnVsbF8sIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbC9udWxsQXN5bmMudHNcbmZ1bmN0aW9uIG51bGxBc3luYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudWxsXCIsXG4gICAgZXhwZWN0czogXCJudWxsXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG51bGxBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udW1iZXIvbnVtYmVyLnRzXG5mdW5jdGlvbiBudW1iZXIoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGV4cGVjdHM6IFwibnVtYmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0KHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG51bWJlciwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udW1iZXIvbnVtYmVyQXN5bmMudHNcbmZ1bmN0aW9uIG51bWJlckFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBleHBlY3RzOiBcIm51bWJlclwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbnVtYmVyQXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0L29iamVjdC50c1xuZnVuY3Rpb24gb2JqZWN0KGVudHJpZXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICBsZXQgY2FjaGVkRW50cmllcztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudHJpZXMsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY2FjaGVkRW50cmllcyA9IGNhY2hlZEVudHJpZXMgPz8gT2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKTtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgc2NoZW1hXSBvZiBjYWNoZWRFbnRyaWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKHZhbHVlMiwgY29uZmlnKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0Lm91dHB1dCAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0ICYmICEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN0Ll9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaXNzdWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgb2JqZWN0LCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdC9vYmplY3RBc3luYy50c1xuZnVuY3Rpb24gb2JqZWN0QXN5bmMoZW50cmllcywgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIGxldCBjYWNoZWRFbnRyaWVzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNhY2hlZEVudHJpZXMgPSBjYWNoZWRFbnRyaWVzID8/IE9iamVjdC5lbnRyaWVzKHRoaXMuZW50cmllcyk7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjYWNoZWRFbnRyaWVzLm1hcChhc3luYyAoW2tleSwgc2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5vdXRwdXQgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRoaXMucmVzdCAmJiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGlucHV0KS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXN0Ll9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICBdKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBvYmplY3RBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vcHRpb25hbC9vcHRpb25hbC50c1xuZnVuY3Rpb24gb3B0aW9uYWwod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IHVuZGVmaW5lZGAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gZ2V0RGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vcHRpb25hbC9vcHRpb25hbEFzeW5jLnRzXG5mdW5jdGlvbiBvcHRpb25hbEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIGV4cGVjdHM6IGAke3dyYXBwZWQuZXhwZWN0c30gfCB1bmRlZmluZWRgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gYXdhaXQgZ2V0RGVmYXVsdEFzeW5jKHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3BpY2tsaXN0L3BpY2tsaXN0LnRzXG5mdW5jdGlvbiBwaWNrbGlzdChvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwaWNrbGlzdFwiLFxuICAgIGV4cGVjdHM6IG9wdGlvbnMubWFwKHN0cmluZ2lmeSkuam9pbihcIiB8IFwiKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmluY2x1ZGVzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBwaWNrbGlzdCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9waWNrbGlzdC9waWNrbGlzdEFzeW5jLnRzXG5mdW5jdGlvbiBwaWNrbGlzdEFzeW5jKG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInBpY2tsaXN0XCIsXG4gICAgZXhwZWN0czogb3B0aW9ucy5tYXAoc3RyaW5naWZ5KS5qb2luKFwiIHwgXCIpLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgcGlja2xpc3RBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpbmcvc3RyaW5nLnRzXG5mdW5jdGlvbiBzdHJpbmcoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGV4cGVjdHM6IFwic3RyaW5nXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzdHJpbmcsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaW5nL3N0cmluZ0FzeW5jLnRzXG5mdW5jdGlvbiBzdHJpbmdBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZXhwZWN0czogXCJzdHJpbmdcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzdHJpbmdBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvdXRpbHMvcmVjb3JkQXJncy9yZWNvcmRBcmdzLnRzXG5mdW5jdGlvbiByZWNvcmRBcmdzKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgaWYgKHR5cGVvZiBhcmcyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGFyZzIpKSB7XG4gICAgY29uc3QgW21lc3NhZ2UyLCBwaXBlMl0gPSBkZWZhdWx0QXJncyhhcmczLCBhcmc0KTtcbiAgICByZXR1cm4gW2FyZzEsIGFyZzIsIG1lc3NhZ2UyLCBwaXBlMl07XG4gIH1cbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoXG4gICAgYXJnMixcbiAgICBhcmczXG4gICk7XG4gIHJldHVybiBbc3RyaW5nKCksIGFyZzEsIG1lc3NhZ2UsIHBpcGVdO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvdmFsdWVzLnRzXG52YXIgQkxPQ0tFRF9LRVlTID0gW1wiX19wcm90b19fXCIsIFwicHJvdG90eXBlXCIsIFwiY29uc3RydWN0b3JcIl07XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmQudHNcbmZ1bmN0aW9uIHJlY29yZChhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtrZXksIHZhbHVlMiwgbWVzc2FnZSwgcGlwZV0gPSByZWNvcmRBcmdzKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgICAgICAgaWYgKCFCTE9DS0VEX0tFWVMuaW5jbHVkZXMoaW5wdXRLZXkpKSB7XG4gICAgICAgICAgICBsZXQgcGF0aEl0ZW07XG4gICAgICAgICAgICBjb25zdCBrZXlSZXN1bHQgPSB0aGlzLmtleS5fcGFyc2UoaW5wdXRLZXksIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoa2V5UmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IGlucHV0S2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2Yga2V5UmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZXMgPSBrZXlSZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdCA9IHRoaXMudmFsdWUuX3BhcnNlKGlucHV0VmFsdWUsIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodmFsdWVSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gPz8ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlzc3VlcyA9IHZhbHVlUmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXlSZXN1bHQudHlwZWQgfHwgIXZhbHVlUmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5UmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIG91dHB1dFtrZXlSZXN1bHQub3V0cHV0XSA9IHZhbHVlUmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaXNzdWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgcmVjb3JkLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmRBc3luYy50c1xuZnVuY3Rpb24gcmVjb3JkQXN5bmMoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBba2V5LCB2YWx1ZTIsIG1lc3NhZ2UsIHBpcGVdID0gcmVjb3JkQXJncyhhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAvLyBOb3RlOiBgT2JqZWN0LmVudHJpZXMoLi4uKWAgY29udmVydHMgZWFjaCBrZXkgdG8gYSBzdHJpbmdcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhpbnB1dCkubWFwKGFzeW5jIChbaW5wdXRLZXksIGlucHV0VmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUJMT0NLRURfS0VZUy5pbmNsdWRlcyhpbnB1dEtleSkpIHtcbiAgICAgICAgICAgICAgbGV0IHBhdGhJdGVtO1xuICAgICAgICAgICAgICBjb25zdCBba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICB7IHNjaGVtYTogdGhpcy5rZXksIHZhbHVlOiBpbnB1dEtleSwgb3JpZ2luOiBcImtleVwiIH0sXG4gICAgICAgICAgICAgICAgICB7IHNjaGVtYTogdGhpcy52YWx1ZSwgdmFsdWU6IGlucHV0VmFsdWUsIG9yaWdpbjogXCJ2YWx1ZVwiIH1cbiAgICAgICAgICAgICAgICBdLm1hcChhc3luYyAoeyBzY2hlbWEsIHZhbHVlOiB2YWx1ZTMsIG9yaWdpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKHZhbHVlMywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aEl0ZW0gPSBwYXRoSXRlbSA/PyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICkuY2F0Y2goKCkgPT4gW10pO1xuICAgICAgICAgICAgICBpZiAoIWtleVJlc3VsdD8udHlwZWQgfHwgIXZhbHVlUmVzdWx0Py50eXBlZCkge1xuICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGtleVJlc3VsdD8udHlwZWQgJiYgdmFsdWVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5UmVzdWx0Lm91dHB1dF0gPSB2YWx1ZVJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGlzc3Vlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHJlY29yZEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NldC9zZXQudHNcbmZ1bmN0aW9uIHNldCh2YWx1ZTIsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBleHBlY3RzOiBcIlNldFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGxldCBrZXkgPSAwO1xuICAgICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgaXNzdWVzO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlLl9wYXJzZShpbnB1dFZhbHVlLCBjb25maWcpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQuYWRkKHJlc3VsdC5vdXRwdXQpO1xuICAgICAgICAgIGtleSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0KHRoaXMsIG91dHB1dCwgY29uZmlnLCBpc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzZXQsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc2V0L3NldEFzeW5jLnRzXG5mdW5jdGlvbiBzZXRBc3luYyh2YWx1ZTIsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBleHBlY3RzOiBcIlNldFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgQXJyYXkuZnJvbShpbnB1dC52YWx1ZXMoKSkubWFwKGFzeW5jIChpbnB1dFZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudmFsdWUuX3BhcnNlKGlucHV0VmFsdWUsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgb3V0cHV0LCBjb25maWcsIGlzc3Vlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHNldEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NwZWNpYWwvc3BlY2lhbC50c1xuZnVuY3Rpb24gc3BlY2lhbChjaGVjaywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwZWNpYWxcIixcbiAgICBleHBlY3RzOiBcInVua25vd25cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgY2hlY2ssXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodGhpcy5jaGVjayhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQodGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgc3BlY2lhbCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zcGVjaWFsL3NwZWNpYWxBc3luYy50c1xuZnVuY3Rpb24gc3BlY2lhbEFzeW5jKGNoZWNrLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3BlY2lhbFwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGNoZWNrLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGF3YWl0IHRoaXMuY2hlY2soaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgc3BlY2lhbEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N5bWJvbC9zeW1ib2wudHNcbmZ1bmN0aW9uIHN5bWJvbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICBleHBlY3RzOiBcInN5bWJvbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHN5bWJvbCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zeW1ib2wvc3ltYm9sQXN5bmMudHNcbmZ1bmN0aW9uIHN5bWJvbEFzeW5jKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN5bWJvbFwiLFxuICAgIGV4cGVjdHM6IFwic3ltYm9sXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzeW1ib2xBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS90dXBsZS50c1xuZnVuY3Rpb24gdHVwbGUoaXRlbXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtc1trZXldLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzdCAmJiAhKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGg7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3QuX3BhcnNlKHZhbHVlMiwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB0dXBsZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS90dXBsZUFzeW5jLnRzXG5mdW5jdGlvbiB0dXBsZUFzeW5jKGl0ZW1zLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAvLyBQYXJzZSBzY2hlbWEgb2YgZWFjaCB0dXBsZSBpdGVtXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoc2NoZW1hLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UodmFsdWUyLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIElmIG5lY2Vzc2FyeSBwYXJzZSBzY2hlbWEgb2YgZWFjaCByZXN0IGl0ZW1cbiAgICAgICAgICB0aGlzLnJlc3QgJiYgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBpbnB1dC5zbGljZSh0aGlzLml0ZW1zLmxlbmd0aCkubWFwKGFzeW5jICh2YWx1ZTIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGggKyBpbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlc3QuX3BhcnNlKHZhbHVlMiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICBdKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB0dXBsZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuZGVmaW5lZC91bmRlZmluZWQudHNcbmZ1bmN0aW9uIHVuZGVmaW5lZF8obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5kZWZpbmVkXCIsXG4gICAgZXhwZWN0czogXCJ1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgdW5kZWZpbmVkXywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmRlZmluZWQvdW5kZWZpbmVkQXN5bmMudHNcbmZ1bmN0aW9uIHVuZGVmaW5lZEFzeW5jKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgIGV4cGVjdHM6IFwidW5kZWZpbmVkXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgdW5kZWZpbmVkQXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdXRpbHMvc3ViaXNzdWVzL3N1Ymlzc3Vlcy50c1xuZnVuY3Rpb24gc3ViaXNzdWVzKHJlc3VsdHMpIHtcbiAgbGV0IGlzc3VlcztcbiAgaWYgKHJlc3VsdHMpIHtcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICBpZiAoaXNzdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzc3Vlcztcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb24udHNcbmZ1bmN0aW9uIHVuaW9uKG9wdGlvbnMsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIGV4cGVjdHM6IFsuLi5uZXcgU2V0KG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSldLmpvaW4oXCIgfCBcIiksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBsZXQgdmFsaWRSZXN1bHQ7XG4gICAgICBsZXQgdW50eXBlZFJlc3VsdHM7XG4gICAgICBsZXQgdHlwZWRSZXN1bHRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIHZhbGlkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVkUmVzdWx0cyA/IHR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB0eXBlZFJlc3VsdHMgPSBbcmVzdWx0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW50eXBlZFJlc3VsdHMgPyB1bnR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB1bnR5cGVkUmVzdWx0cyA9IFtyZXN1bHRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQodGhpcywgdmFsaWRSZXN1bHQub3V0cHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVkUmVzdWx0cz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVzdWx0ID0gdHlwZWRSZXN1bHRzWzBdO1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGZpcnN0UmVzdWx0Lm91dHB1dCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgLy8gSGludDogSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSB0eXBlZCByZXN1bHQsIHdlIHVzZSBhIGdlbmVyYWxcbiAgICAgICAgICAvLyB1bmlvbiBpc3N1ZSB3aXRoIHN1Ymlzc3VlcyBiZWNhdXNlIHRoZSBpc3N1ZXMgY291bGQgY29udHJhZGljdFxuICAgICAgICAgIC8vIGVhY2ggb3RoZXIuXG4gICAgICAgICAgdHlwZWRSZXN1bHRzLmxlbmd0aCA9PT0gMSA/IGZpcnN0UmVzdWx0Lmlzc3VlcyA6IHNjaGVtYUlzc3VlKHRoaXMsIHVuaW9uLCBpbnB1dCwgY29uZmlnLCB7XG4gICAgICAgICAgICByZWFzb246IFwidW5pb25cIixcbiAgICAgICAgICAgIGlzc3Vlczogc3ViaXNzdWVzKHR5cGVkUmVzdWx0cylcbiAgICAgICAgICB9KS5pc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnR5cGVkUmVzdWx0cz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB1bnR5cGVkUmVzdWx0c1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB1bmlvbiwgaW5wdXQsIGNvbmZpZywge1xuICAgICAgICBpc3N1ZXM6IHN1Ymlzc3Vlcyh1bnR5cGVkUmVzdWx0cylcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb25Bc3luYy50c1xuZnVuY3Rpb24gdW5pb25Bc3luYyhvcHRpb25zLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBleHBlY3RzOiBbLi4ubmV3IFNldChvcHRpb25zLm1hcCgob3B0aW9uKSA9PiBvcHRpb24uZXhwZWN0cykpXS5qb2luKFwiIHwgXCIpLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBsZXQgdmFsaWRSZXN1bHQ7XG4gICAgICBsZXQgdW50eXBlZFJlc3VsdHM7XG4gICAgICBsZXQgdHlwZWRSZXN1bHRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIHZhbGlkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVkUmVzdWx0cyA/IHR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB0eXBlZFJlc3VsdHMgPSBbcmVzdWx0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW50eXBlZFJlc3VsdHMgPyB1bnR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB1bnR5cGVkUmVzdWx0cyA9IFtyZXN1bHRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCB2YWxpZFJlc3VsdC5vdXRwdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWRSZXN1bHRzPy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RSZXN1bHQgPSB0eXBlZFJlc3VsdHNbMF07XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBmaXJzdFJlc3VsdC5vdXRwdXQsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIC8vIEhpbnQ6IElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgdHlwZWQgcmVzdWx0LCB3ZSB1c2UgYSBnZW5lcmFsXG4gICAgICAgICAgLy8gdW5pb24gaXNzdWUgd2l0aCBzdWJpc3N1ZXMgYmVjYXVzZSB0aGUgaXNzdWVzIGNvdWxkIGNvbnRyYWRpY3RcbiAgICAgICAgICAvLyBlYWNoIG90aGVyLlxuICAgICAgICAgIHR5cGVkUmVzdWx0cy5sZW5ndGggPT09IDEgPyBmaXJzdFJlc3VsdC5pc3N1ZXMgOiBzY2hlbWFJc3N1ZSh0aGlzLCB1bmlvbkFzeW5jLCBpbnB1dCwgY29uZmlnLCB7XG4gICAgICAgICAgICByZWFzb246IFwidW5pb25cIixcbiAgICAgICAgICAgIGlzc3Vlczogc3ViaXNzdWVzKHR5cGVkUmVzdWx0cylcbiAgICAgICAgICB9KS5pc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnR5cGVkUmVzdWx0cz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB1bnR5cGVkUmVzdWx0c1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB1bmlvbkFzeW5jLCBpbnB1dCwgY29uZmlnLCB7XG4gICAgICAgIGlzc3Vlczogc3ViaXNzdWVzKHVudHlwZWRSZXN1bHRzKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmtub3duL3Vua25vd24udHNcbmZ1bmN0aW9uIHVua25vd24ocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3Vua25vd24vdW5rbm93bkFzeW5jLnRzXG5mdW5jdGlvbiB1bmtub3duQXN5bmMocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy92YXJpYW50L3ZhcmlhbnQudHNcbmZ1bmN0aW9uIHZhcmlhbnQoa2V5LCBvcHRpb25zLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICBsZXQgY2FjaGVkRXhwZWN0ZWRLZXk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2YXJpYW50XCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0aGlzLmtleSBpbiBpbnB1dCB8fCAhY2FjaGVkRXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgICBsZXQgZXhwZWN0ZWRLZXk7XG4gICAgICAgICAgbGV0IHZhcmlhbnRSZXN1bHQ7XG4gICAgICAgICAgY29uc3QgcGFyc2VPcHRpb25zID0gKG9wdGlvbnMyKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBvcHRpb25zMikge1xuICAgICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTY2hlbWEgPSBzY2hlbWEuZW50cmllc1t0aGlzLmtleV07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0ga2V5U2NoZW1hLl9wYXJzZShcbiAgICAgICAgICAgICAgICAgIGlucHV0W3RoaXMua2V5XSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRFeHBlY3RlZEtleSkge1xuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRLZXkgPyBleHBlY3RlZEtleS5wdXNoKGtleVNjaGVtYS5leHBlY3RzKSA6IGV4cGVjdGVkS2V5ID0gW2tleVNjaGVtYS5leHBlY3RzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgIGlmICghZGF0YVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudFJlc3VsdCA9IGRhdGFSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCF2YXJpYW50UmVzdWx0IHx8ICF2YXJpYW50UmVzdWx0LnR5cGVkICYmIGRhdGFSZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudFJlc3VsdCA9IGRhdGFSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSBcInZhcmlhbnRcIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9ucyhzY2hlbWEub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbnRSZXN1bHQgJiYgIXZhcmlhbnRSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIGNhY2hlZEV4cGVjdGVkS2V5ID0gY2FjaGVkRXhwZWN0ZWRLZXkgfHwgWy4uLm5ldyBTZXQoZXhwZWN0ZWRLZXkpXS5qb2luKFwiIHwgXCIpO1xuICAgICAgICAgIGlmICh2YXJpYW50UmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodmFyaWFudFJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRSZXN1bHQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0Lmlzc3Vlc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W3RoaXMua2V5XTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHZhcmlhbnQsIHZhbHVlMiwgY29uZmlnLCB7XG4gICAgICAgICAgZXhwZWN0ZWQ6IGNhY2hlZEV4cGVjdGVkS2V5LFxuICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB2YXJpYW50LCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdmFyaWFudEFzeW5jLnRzXG5mdW5jdGlvbiB2YXJpYW50QXN5bmMoa2V5LCBvcHRpb25zLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICBsZXQgY2FjaGVkRXhwZWN0ZWRLZXk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2YXJpYW50XCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBrZXksXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5IGluIGlucHV0IHx8ICFjYWNoZWRFeHBlY3RlZEtleSkge1xuICAgICAgICAgIGxldCBleHBlY3RlZEtleTtcbiAgICAgICAgICBsZXQgdmFyaWFudFJlc3VsdDtcbiAgICAgICAgICBjb25zdCBwYXJzZU9wdGlvbnMgPSBhc3luYyAob3B0aW9uczIpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIG9wdGlvbnMyKSB7XG4gICAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNjaGVtYSA9IHNjaGVtYS5lbnRyaWVzW3RoaXMua2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlSZXN1bHQgPSBhd2FpdCBrZXlTY2hlbWEuX3BhcnNlKFxuICAgICAgICAgICAgICAgICAgaW5wdXRbdGhpcy5rZXldLFxuICAgICAgICAgICAgICAgICAgY29uZmlnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZEV4cGVjdGVkS2V5KSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3RlZEtleSA/IGV4cGVjdGVkS2V5LnB1c2goa2V5U2NoZW1hLmV4cGVjdHMpIDogZXhwZWN0ZWRLZXkgPSBba2V5U2NoZW1hLmV4cGVjdHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWtleVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFSZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0ID0gZGF0YVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXZhcmlhbnRSZXN1bHQgfHwgIXZhcmlhbnRSZXN1bHQudHlwZWQgJiYgZGF0YVJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0ID0gZGF0YVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09IFwidmFyaWFudFwiKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFyc2VPcHRpb25zKHNjaGVtYS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFudFJlc3VsdCAmJiAhdmFyaWFudFJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXdhaXQgcGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgY2FjaGVkRXhwZWN0ZWRLZXkgPSBjYWNoZWRFeHBlY3RlZEtleSB8fCBbLi4ubmV3IFNldChleHBlY3RlZEtleSldLmpvaW4oXCIgfCBcIik7XG4gICAgICAgICAgaWYgKHZhcmlhbnRSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh2YXJpYW50UmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgdmFyaWFudFJlc3VsdC5pc3N1ZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50UmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFt0aGlzLmtleV07XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB2YXJpYW50QXN5bmMsIHZhbHVlMiwgY29uZmlnLCB7XG4gICAgICAgICAgZXhwZWN0ZWQ6IGNhY2hlZEV4cGVjdGVkS2V5LFxuICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB2YXJpYW50QXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdm9pZC92b2lkLnRzXG5mdW5jdGlvbiB2b2lkXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2b2lkXCIsXG4gICAgZXhwZWN0czogXCJ2b2lkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHZvaWRfLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZvaWQvdm9pZEFzeW5jLnRzXG5mdW5jdGlvbiB2b2lkQXN5bmMobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidm9pZFwiLFxuICAgIGV4cGVjdHM6IFwidm9pZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHZvaWRBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9rZXlvZi9rZXlvZi50c1xuZnVuY3Rpb24ga2V5b2Yoc2NoZW1hKSB7XG4gIHJldHVybiBwaWNrbGlzdChcbiAgICBPYmplY3Qua2V5cyhzY2hlbWEuZW50cmllcylcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvbWVyZ2UvbWVyZ2UudHNcbmZ1bmN0aW9uIG1lcmdlKHNjaGVtYXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0KFxuICAgIHNjaGVtYXMucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIHNjaGVtYSkgPT4gKHsgLi4uZW50cmllcywgLi4uc2NoZW1hLmVudHJpZXMgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvbWVyZ2UvbWVyZ2VBc3luYy50c1xuZnVuY3Rpb24gbWVyZ2VBc3luYyhzY2hlbWFzLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIHNjaGVtYXMucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIHNjaGVtYSkgPT4gKHsgLi4uZW50cmllcywgLi4uc2NoZW1hLmVudHJpZXMgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvb21pdC9vbWl0LnRzXG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwga2V5cywgYXJnMywgYXJnNCwgYXJnNSkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMywgYXJnNCwgYXJnNSk7XG4gIHJldHVybiBvYmplY3QoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLnJlZHVjZShcbiAgICAgIChlbnRyaWVzLCBba2V5LCBzY2hlbWEyXSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpID8gZW50cmllcyA6IHsgLi4uZW50cmllcywgW2tleV06IHNjaGVtYTIgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9vbWl0L29taXRBc3luYy50c1xuZnVuY3Rpb24gb21pdEFzeW5jKHNjaGVtYSwga2V5cywgYXJnMywgYXJnNCwgYXJnNSkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMywgYXJnNCwgYXJnNSk7XG4gIHJldHVybiBvYmplY3RBc3luYyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkgPyBlbnRyaWVzIDogeyAuLi5lbnRyaWVzLCBba2V5XTogc2NoZW1hMiB9LFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlL3BhcnNlLnRzXG5mdW5jdGlvbiBwYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcpIHtcbiAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZykpO1xuICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IocmVzdWx0Lmlzc3Vlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5vdXRwdXQ7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlL3BhcnNlQXN5bmMudHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGdldEdsb2JhbENvbmZpZyhjb25maWcpKTtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaUVycm9yKHJlc3VsdC5pc3N1ZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQub3V0cHV0O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJ0aWFsL3BhcnRpYWwudHNcbmZ1bmN0aW9uIHBhcnRpYWwoc2NoZW1hLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdChcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiAoe1xuICAgICAgICAuLi5lbnRyaWVzLFxuICAgICAgICBba2V5XTogb3B0aW9uYWwoc2NoZW1hMilcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnRpYWwvcGFydGlhbEFzeW5jLnRzXG5mdW5jdGlvbiBwYXJ0aWFsQXN5bmMoc2NoZW1hLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+ICh7XG4gICAgICAgIC4uLmVudHJpZXMsXG4gICAgICAgIFtrZXldOiBvcHRpb25hbEFzeW5jKHNjaGVtYTIpXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waWNrL3BpY2sudHNcbmZ1bmN0aW9uIHBpY2soc2NoZW1hLCBrZXlzLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmczLCBhcmc0LCBhcmc1KTtcbiAgcmV0dXJuIG9iamVjdChcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkgPyB7IC4uLmVudHJpZXMsIFtrZXldOiBzY2hlbWEyIH0gOiBlbnRyaWVzLFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BpY2svcGlja0FzeW5jLnRzXG5mdW5jdGlvbiBwaWNrQXN5bmMoc2NoZW1hLCBrZXlzLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmczLCBhcmc0LCBhcmc1KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+IGtleXMuaW5jbHVkZXMoa2V5KSA/IHsgLi4uZW50cmllcywgW2tleV06IHNjaGVtYTIgfSA6IGVudHJpZXMsXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcmVxdWlyZWQvcmVxdWlyZWQudHNcbmZ1bmN0aW9uIHJlcXVpcmVkKHNjaGVtYSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiBvYmplY3QoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLnJlZHVjZShcbiAgICAgIChlbnRyaWVzLCBba2V5LCBzY2hlbWEyXSkgPT4gKHtcbiAgICAgICAgLi4uZW50cmllcyxcbiAgICAgICAgW2tleV06IG5vbk9wdGlvbmFsKHNjaGVtYTIpXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9yZXF1aXJlZC9yZXF1aXJlZEFzeW5jLnRzXG5mdW5jdGlvbiByZXF1aXJlZEFzeW5jKHNjaGVtYSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiBvYmplY3RBc3luYyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiAoe1xuICAgICAgICAuLi5lbnRyaWVzLFxuICAgICAgICBba2V5XTogbm9uT3B0aW9uYWxBc3luYyhzY2hlbWEyKVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlL3NhZmVQYXJzZS50c1xuZnVuY3Rpb24gc2FmZVBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZykge1xuICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBnZXRHbG9iYWxDb25maWcoY29uZmlnKSk7XG4gIHJldHVybiB7XG4gICAgdHlwZWQ6IHJlc3VsdC50eXBlZCxcbiAgICBzdWNjZXNzOiAhcmVzdWx0Lmlzc3VlcyxcbiAgICBvdXRwdXQ6IHJlc3VsdC5vdXRwdXQsXG4gICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gc2FmZVBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGdldEdsb2JhbENvbmZpZyhjb25maWcpKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlZDogcmVzdWx0LnR5cGVkLFxuICAgIHN1Y2Nlc3M6ICFyZXN1bHQuaXNzdWVzLFxuICAgIG91dHB1dDogcmVzdWx0Lm91dHB1dCxcbiAgICBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXNcbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvdHJhbnNmb3JtL3RyYW5zZm9ybS50c1xuZnVuY3Rpb24gdHJhbnNmb3JtKHNjaGVtYSwgYWN0aW9uLCBhcmcxKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgcmVzdWx0LnR5cGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQub3V0cHV0ID0gYWN0aW9uKHJlc3VsdC5vdXRwdXQsIHsgaXNzdWVzOiByZXN1bHQuaXNzdWVzIH0pO1xuICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICAgICAgeyB0eXBlOiB0eXBlb2YgcmVzdWx0Lm91dHB1dCwgcGlwZTogYXJnMSB9LFxuICAgICAgICAgICAgICByZXN1bHQub3V0cHV0LFxuICAgICAgICAgICAgICBjb25maWdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcmcxLl9wYXJzZShyZXN1bHQub3V0cHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvdHJhbnNmb3JtL3RyYW5zZm9ybUFzeW5jLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1Bc3luYyhzY2hlbWEsIGFjdGlvbiwgYXJnMSkge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgIHJlc3VsdC50eXBlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm91dHB1dCA9IGF3YWl0IGFjdGlvbihyZXN1bHQub3V0cHV0LCB7IGlzc3VlczogcmVzdWx0Lmlzc3VlcyB9KTtcbiAgICAgICAgaWYgKGFyZzEpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhcbiAgICAgICAgICAgICAgeyB0eXBlOiB0eXBlb2YgcmVzdWx0Lm91dHB1dCwgcGlwZTogYXJnMSB9LFxuICAgICAgICAgICAgICByZXN1bHQub3V0cHV0LFxuICAgICAgICAgICAgICBjb25maWdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcmcxLl9wYXJzZShyZXN1bHQub3V0cHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvdW53cmFwL3Vud3JhcC50c1xuZnVuY3Rpb24gdW53cmFwKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hLndyYXBwZWQ7XG59XG5cbi8vIHNyYy9yZWdleC50c1xudmFyIEJJQ19SRUdFWCA9IC9eW0EtWl17Nn0oPyEwMClbQS1aXFxkXXsyfSg/OltBLVpcXGRdezN9KT8kL3U7XG52YXIgQ1VJRDJfUkVHRVggPSAvXlthLXpdW1xcZGEtel0qJC91O1xudmFyIERFQ0lNQUxfUkVHRVggPSAvXlxcZCskL3U7XG52YXIgRU1BSUxfUkVHRVggPSAvXltcXHcrLV0rKD86XFwuW1xcdystXSspKkBbXFxkYS16XSsoPzpbLi1dW1xcZGEtel0rKSpcXC5bYS16XXsyLH0kL2l1O1xudmFyIEVNT0pJX1JFR0VYID0gL15bXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY31cXHB7RW1vamlfQ29tcG9uZW50fV0rJC91O1xudmFyIEhFWEFERUNJTUFMX1JFR0VYID0gL14oMGh8MHgpP1tcXGRhLWZdKyQvaXU7XG52YXIgSEVYX0NPTE9SX1JFR0VYID0gL14jKFtcXGRhLWZdezN9fFtcXGRhLWZdezR9fFtcXGRhLWZdezZ9fFtcXGRhLWZdezh9KSQvaXU7XG52YXIgSU1FSV9SRUdFWCA9IC9eXFxkezJ9KD86WyAvfC1dP1xcZHs2fSl7Mn1bIC98LV0/XFxkJC91O1xudmFyIElQVjRfUkVHRVggPSAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy1kZXRlY3Rvci9uby11bnNhZmUtcmVnZXggLS0gZmFsc2UgcG9zaXRpdmVcbiAgL14oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKD86XFwuKD86KD86WzEtOV18MVxcZHwyWzAtNF0pP1xcZHwyNVswLTVdKSl7M30kL3Vcbik7XG52YXIgSVBWNl9SRUdFWCA9IC9eKD86KD86W1xcZGEtZl17MSw0fTopezd9W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw3fTp8KD86W1xcZGEtZl17MSw0fTopezEsNn06W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw1fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDJ9fCg/OltcXGRhLWZdezEsNH06KXsxLDR9KD86OltcXGRhLWZdezEsNH0pezEsM318KD86W1xcZGEtZl17MSw0fTopezEsM30oPzo6W1xcZGEtZl17MSw0fSl7MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSwyfSg/OjpbXFxkYS1mXXsxLDR9KXsxLDV9fFtcXGRhLWZdezEsNH06KD86OltcXGRhLWZdezEsNH0pezEsNn18Oig/Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDd9fDopfGZlODA6KD86OltcXGRhLWZdezAsNH0pezAsNH0lW1xcZGEtel0rfDo6KD86Zns0fSg/OjowezEsNH0pPzopPyg/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpfCg/OltcXGRhLWZdezEsNH06KXsxLDR9Oig/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpKSQvaXU7XG52YXIgSVNPX0RBVEVfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSkkL3U7XG52YXIgSVNPX0RBVEVfVElNRV9SRUdFWCA9IC9eXFxkezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKVQoPzowXFxkfDFcXGR8MlswLTNdKTpbMC01XVxcZCQvdTtcbnZhciBJU09fVElNRV9SRUdFWCA9IC9eKD86MFxcZHwxXFxkfDJbMC0zXSk6WzAtNV1cXGQkL3U7XG52YXIgSVNPX1RJTUVfU0VDT05EX1JFR0VYID0gL14oPzowXFxkfDFcXGR8MlswLTNdKSg/OjpbMC01XVxcZCl7Mn0kL3U7XG52YXIgSVNPX1RJTUVTVEFNUF9SRUdFWCA9IC9eXFxkezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKVQoPzowXFxkfDFcXGR8MlswLTNdKSg/OjpbMC01XVxcZCl7Mn0oPzpcXC5cXGR7MSw5fSk/WiQvdTtcbnZhciBJU09fV0VFS19SRUdFWCA9IC9eXFxkezR9LVcoPzowWzEtOV18WzEtNF1cXGR8NVswLTNdKSQvdTtcbnZhciBNQUM0OF9SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezJ9W1xcZGEtZl17NH0kL2l1O1xudmFyIE1BQzY0X1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7M31bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezR9Oil7M31bXFxkYS1mXXs0fSQvaXU7XG52YXIgT0NUQUxfUkVHRVggPSAvXigwbyk/WzAtN10rJC9pdTtcbnZhciBVTElEX1JFR0VYID0gL15bXFxkYS1oamttbnAtdHYtel17MjZ9JC9pdTtcbnZhciBVVUlEX1JFR0VYID0gL15bXFxkYS1mXXs4fSg/Oi1bXFxkYS1mXXs0fSl7M30tW1xcZGEtZl17MTJ9JC9pdTtcblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0N1c3RvbS90b0N1c3RvbS50c1xuZnVuY3Rpb24gdG9DdXN0b20oYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b19jdXN0b21cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGFjdGlvbihpbnB1dCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0N1c3RvbS90b0N1c3RvbUFzeW5jLnRzXG5mdW5jdGlvbiB0b0N1c3RvbUFzeW5jKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fY3VzdG9tXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGF3YWl0IGFjdGlvbihpbnB1dCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0xvd2VyQ2FzZS90b0xvd2VyQ2FzZS50c1xuZnVuY3Rpb24gdG9Mb3dlckNhc2UoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b19sb3dlcl9jYXNlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dC50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9NYXhWYWx1ZS90b01heFZhbHVlLnRzXG5mdW5jdGlvbiB0b01heFZhbHVlKHJlcXVpcmVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b19tYXhfdmFsdWVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0ID4gdGhpcy5yZXF1aXJlbWVudCA/IHRoaXMucmVxdWlyZW1lbnQgOiBpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtYXRpb25zL3RvTWluVmFsdWUvdG9NaW5WYWx1ZS50c1xuZnVuY3Rpb24gdG9NaW5WYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fbWluX3ZhbHVlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCA8IHRoaXMucmVxdWlyZW1lbnQgPyB0aGlzLnJlcXVpcmVtZW50IDogaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b1RyaW1tZWQvdG9UcmltbWVkLnRzXG5mdW5jdGlvbiB0b1RyaW1tZWQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b190cmltbWVkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dC50cmltKCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b1RyaW1tZWRFbmQvdG9UcmltbWVkRW5kLnRzXG5mdW5jdGlvbiB0b1RyaW1tZWRFbmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b190cmltbWVkX2VuZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQudHJpbUVuZCgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9UcmltbWVkU3RhcnQvdG9UcmltbWVkU3RhcnQudHNcbmZ1bmN0aW9uIHRvVHJpbW1lZFN0YXJ0KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fdHJpbW1lZF9zdGFydFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQudHJpbVN0YXJ0KCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b1VwcGVyQ2FzZS90b1VwcGVyQ2FzZS50c1xuZnVuY3Rpb24gdG9VcHBlckNhc2UoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b191cHBlcl9jYXNlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dC50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9iaWMvYmljLnRzXG5mdW5jdGlvbiBiaWMobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmljXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogQklDX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgYmljLCBpbnB1dCwgXCJCSUNcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvYnl0ZXMvYnl0ZXMudHNcbmZ1bmN0aW9uIGJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJieXRlc1wiLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBjb25zdCBsZW5ndGgyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGlucHV0KS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoMiA9PT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBieXRlcywgaW5wdXQsIFwiYnl0ZXNcIiwgYCR7bGVuZ3RoMn1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9jcmVkaXRDYXJkL2NyZWRpdENhcmQudHNcbnZhciBTQU5JVElaRV9SRUdFWCA9IC9bLSBdKy9ndTtcbnZhciBQUk9WSURFUl9SRUdFWF9MSVNUID0gW1xuICAvLyBBbWVyaWNhbiBFeHByZXNzXG4gIC9eM1s0N11cXGR7MTN9JC91LFxuICAvLyBEaW5lcnMgQ2x1YlxuICAvXjMoPzowWzAtNV18WzY4XVxcZClcXGR7MTF9JC91LFxuICAvLyBEaXNjb3ZlclxuICAvXjYoPzowMTF8NVxcZHsyfSlcXGR7MTIsMTV9JC91LFxuICAvLyBKQ0JcbiAgL14oPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfSQvdSxcbiAgLy8gTWFzdGVyY2FyZFxuICAvXjVbMS01XVxcZHsyfXwoMjIyXFxkfDIyWzMtOV1cXGR8MlszLTZdXFxkezJ9fDI3WzAxXVxcZHwyNzIwKVxcZHsxMn0kL3UsXG4gIC8vIFVuaW9uUGF5XG4gIC9eKDZbMjddXFxkezE0fXw4MVxcZHsxNCwxN30pJC91LFxuICAvLyBWaXNhXG4gIC9eNFxcZHsxMn0oPzpcXGR7Myw2fSk/JC91XG5dO1xuZnVuY3Rpb24gY3JlZGl0Q2FyZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjcmVkaXRfY2FyZFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IChpbnB1dCkgPT4ge1xuICAgICAgY29uc3Qgc2FuaXRpemVkID0gaW5wdXQucmVwbGFjZShTQU5JVElaRV9SRUdFWCwgXCJcIik7XG4gICAgICByZXR1cm4gUFJPVklERVJfUkVHRVhfTElTVC5zb21lKChyZWdleDIpID0+IHJlZ2V4Mi50ZXN0KHNhbml0aXplZCkpICYmIGlzTHVobkFsZ28oc2FuaXRpemVkKTtcbiAgICB9LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGNyZWRpdENhcmQsIGlucHV0LCBcImNyZWRpdCBjYXJkXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1aWQyL2N1aWQyLnRzXG5mdW5jdGlvbiBjdWlkMihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjdWlkMlwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IENVSUQyX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgY3VpZDIsIGlucHV0LCBcIkN1aWQyXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1c3RvbS9jdXN0b20udHNcbmZ1bmN0aW9uIGN1c3RvbShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBjdXN0b20sIGlucHV0LCBcImlucHV0XCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1c3RvbS9jdXN0b21Bc3luYy50c1xuZnVuY3Rpb24gY3VzdG9tQXN5bmMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChhd2FpdCB0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBjdXN0b21Bc3luYywgaW5wdXQsIFwiaW5wdXRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZGVjaW1hbC9kZWNpbWFsLnRzXG5mdW5jdGlvbiBkZWNpbWFsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImRlY2ltYWxcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBERUNJTUFMX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgZGVjaW1hbCwgaW5wdXQsIFwiZGVjaW1hbFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lbWFpbC9lbWFpbC50c1xuZnVuY3Rpb24gZW1haWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW1haWxcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBFTUFJTF9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGVtYWlsLCBpbnB1dCwgXCJlbWFpbFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lbW9qaS9lbW9qaS50c1xuZnVuY3Rpb24gZW1vamkobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW1vamlcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBFTU9KSV9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGVtb2ppLCBpbnB1dCwgXCJlbW9qaVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lbmRzV2l0aC9lbmRzV2l0aC50c1xuZnVuY3Rpb24gZW5kc1dpdGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVuZHNfd2l0aFwiLFxuICAgIGV4cGVjdHM6IGBcIiR7cmVxdWlyZW1lbnR9XCJgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKGlucHV0LmVuZHNXaXRoKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBlbmRzV2l0aCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIFwiZW5kXCIsXG4gICAgICAgIGBcIiR7aW5wdXQuc2xpY2UoLXRoaXMucmVxdWlyZW1lbnQubGVuZ3RoKX1cImBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZXZlcnkvZXZlcnkudHNcbmZ1bmN0aW9uIGV2ZXJ5KHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJldmVyeVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuZXZlcnkodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgZXZlcnksIGlucHV0LCBcImlucHV0XCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2V4Y2x1ZGVzL2V4Y2x1ZGVzLnRzXG5mdW5jdGlvbiBleGNsdWRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICBjb25zdCByZWNlaXZlZCA9IHN0cmluZ2lmeShyZXF1aXJlbWVudCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJleGNsdWRlc1wiLFxuICAgIGV4cGVjdHM6IGAhJHtyZWNlaXZlZH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKCFpbnB1dC5pbmNsdWRlcyh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBleGNsdWRlcywgaW5wdXQsIFwiY29udGVudFwiLCByZWNlaXZlZCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZmluaXRlL2Zpbml0ZS50c1xuZnVuY3Rpb24gZmluaXRlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImZpbml0ZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc0Zpbml0ZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBmaW5pdGUsIGlucHV0LCBcImZpbml0ZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9oYXNoL2hhc2gudHNcbnZhciBIQVNIX0xFTkdUSFMgPSB7XG4gIG1kNDogMzIsXG4gIG1kNTogMzIsXG4gIHNoYTE6IDQwLFxuICBzaGEyNTY6IDY0LFxuICBzaGEzODQ6IDk2LFxuICBzaGE1MTI6IDEyOCxcbiAgcmlwZW1kMTI4OiAzMixcbiAgcmlwZW1kMTYwOiA0MCxcbiAgdGlnZXIxMjg6IDMyLFxuICB0aWdlcjE2MDogNDAsXG4gIHRpZ2VyMTkyOiA0OCxcbiAgY3JjMzI6IDgsXG4gIGNyYzMyYjogOCxcbiAgYWRsZXIzMjogOFxufTtcbmZ1bmN0aW9uIGhhc2godHlwZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImhhc2hcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBSZWdFeHAoXG4gICAgICB0eXBlcy5tYXAoKHR5cGUpID0+IGBeW2EtZjAtOV17JHtIQVNIX0xFTkdUSFNbdHlwZV19fSRgKS5qb2luKFwifFwiKSxcbiAgICAgIFwiaXVcIlxuICAgICksXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBoYXNoLCBpbnB1dCwgXCJoYXNoXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2hleGFkZWNpbWFsL2hleGFkZWNpbWFsLnRzXG5mdW5jdGlvbiBoZXhhZGVjaW1hbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJoZXhhZGVjaW1hbFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IEhFWEFERUNJTUFMX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaGV4YWRlY2ltYWwsIGlucHV0LCBcImhleGFkZWNpbWFsXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2hleENvbG9yL2hleENvbG9yLnRzXG5mdW5jdGlvbiBoZXhDb2xvcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJoZXhfY29sb3JcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBIRVhfQ09MT1JfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBoZXhDb2xvciwgaW5wdXQsIFwiaGV4IGNvbG9yXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2ltZWkvaW1laS50c1xuZnVuY3Rpb24gaW1laShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbWVpXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogW0lNRUlfUkVHRVgsIGlzTHVobkFsZ29dLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnRbMF0udGVzdChpbnB1dCkgJiYgdGhpcy5yZXF1aXJlbWVudFsxXShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaW1laSwgaW5wdXQsIFwiSU1FSVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pbmNsdWRlcy9pbmNsdWRlcy50c1xuZnVuY3Rpb24gaW5jbHVkZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgY29uc3QgZXhwZWN0cyA9IHN0cmluZ2lmeShyZXF1aXJlbWVudCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbmNsdWRlc1wiLFxuICAgIGV4cGVjdHMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuaW5jbHVkZXModGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaW5jbHVkZXMsIGlucHV0LCBcImNvbnRlbnRcIiwgYCEke2V4cGVjdHN9YCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaW50ZWdlci9pbnRlZ2VyLnRzXG5mdW5jdGlvbiBpbnRlZ2VyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBOdW1iZXIuaXNJbnRlZ2VyLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGludGVnZXIsIGlucHV0LCBcImludGVnZXJcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXAvaXAudHNcbmZ1bmN0aW9uIGlwKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlwXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICAvLyBUT0RPOiBJdCBpcyBzdHJhbmdlIHRoYXQgd2UgaGF2ZSBhbiBPUiByZWxhdGlvbnNoaXAgYmV0d2VlbiByZXF1aXJlbWVudHNcbiAgICByZXF1aXJlbWVudDogW0lQVjRfUkVHRVgsIElQVjZfUkVHRVhdLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnRbMF0udGVzdChpbnB1dCkgfHwgdGhpcy5yZXF1aXJlbWVudFsxXS50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpcCwgaW5wdXQsIFwiSVBcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXB2NC9pcHY0LnRzXG5mdW5jdGlvbiBpcHY0KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlwdjRcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJUFY0X1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXB2NCwgaW5wdXQsIFwiSVB2NFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pcHY2L2lwdjYudHNcbmZ1bmN0aW9uIGlwdjYobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXB2NlwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElQVjZfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpcHY2LCBpbnB1dCwgXCJJUHY2XCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb0RhdGUvaXNvRGF0ZS50c1xuZnVuY3Rpb24gaXNvRGF0ZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpc29fZGF0ZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19EQVRFX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvRGF0ZSwgaW5wdXQsIFwiZGF0ZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29EYXRlVGltZS9pc29EYXRlVGltZS50c1xuZnVuY3Rpb24gaXNvRGF0ZVRpbWUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXNvX2RhdGVfdGltZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19EQVRFX1RJTUVfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpc29EYXRlVGltZSwgaW5wdXQsIFwiZGF0ZS10aW1lXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb1RpbWUvaXNvVGltZS50c1xuZnVuY3Rpb24gaXNvVGltZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpc29fdGltZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19USU1FX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvVGltZSwgaW5wdXQsIFwidGltZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29UaW1lU2Vjb25kL2lzb1RpbWVTZWNvbmQudHNcbmZ1bmN0aW9uIGlzb1RpbWVTZWNvbmQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXNvX3RpbWVfc2Vjb25kXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogSVNPX1RJTUVfU0VDT05EX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvVGltZVNlY29uZCwgaW5wdXQsIFwidGltZSBzZWNvbmRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvVGltZXN0YW1wL2lzb1RpbWVzdGFtcC50c1xuZnVuY3Rpb24gaXNvVGltZXN0YW1wKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlzb190aW1lc3RhbXBcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRVNUQU1QX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvVGltZXN0YW1wLCBpbnB1dCwgXCJ0aW1lc3RhbXBcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvV2Vlay9pc29XZWVrLnRzXG5mdW5jdGlvbiBpc29XZWVrKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlzb193ZWVrXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogSVNPX1dFRUtfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpc29XZWVrLCBpbnB1dCwgXCJ3ZWVrXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2xlbmd0aC9sZW5ndGgudHNcbmZ1bmN0aW9uIGxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGVuZ3RoXCIsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21hYy9tYWMudHNcbmZ1bmN0aW9uIG1hYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtYWNcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIC8vIFRPRE86IEl0IGlzIHN0cmFuZ2UgdGhhdCB3ZSBoYXZlIGFuIE9SIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHJlcXVpcmVtZW50c1xuICAgIHJlcXVpcmVtZW50OiBbTUFDNDhfUkVHRVgsIE1BQzY0X1JFR0VYXSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50WzBdLnRlc3QoaW5wdXQpIHx8IHRoaXMucmVxdWlyZW1lbnRbMV0udGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWFjLCBpbnB1dCwgXCJNQUNcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWFjNDgvbWFjNDgudHNcbmZ1bmN0aW9uIG1hYzQ4KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1hYzQ4XCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogTUFDNDhfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBtYWM0OCwgaW5wdXQsIFwiNDgtYml0IE1BQ1wiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYWM2NC9tYWM2NC50c1xuZnVuY3Rpb24gbWFjNjQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWFjNjRcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBNQUM2NF9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG1hYzY0LCBpbnB1dCwgXCI2NC1iaXQgTUFDXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21heEJ5dGVzL21heEJ5dGVzLnRzXG5mdW5jdGlvbiBtYXhCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWF4X2J5dGVzXCIsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgY29uc3QgbGVuZ3RoMiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aDIgPD0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBtYXhCeXRlcywgaW5wdXQsIFwiYnl0ZXNcIiwgYCR7bGVuZ3RoMn1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYXhMZW5ndGgvbWF4TGVuZ3RoLnRzXG5mdW5jdGlvbiBtYXhMZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1heF9sZW5ndGhcIixcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWF4TGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21heFNpemUvbWF4U2l6ZS50c1xuZnVuY3Rpb24gbWF4U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWF4X3NpemVcIixcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2l6ZSA8PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG1heFNpemUsIGlucHV0LCBcInNpemVcIiwgYCR7aW5wdXQuc2l6ZX1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYXhWYWx1ZS9tYXhWYWx1ZS50c1xuZnVuY3Rpb24gbWF4VmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1heF92YWx1ZVwiLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBzdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPD0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWF4VmFsdWUsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSA/IGlucHV0LnRvSlNPTigpIDogc3RyaW5naWZ5KGlucHV0KVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5CeXRlcy9taW5CeXRlcy50c1xuZnVuY3Rpb24gbWluQnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl9ieXRlc1wiLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGNvbnN0IGxlbmd0aDIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5wdXQpLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgyID49IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWluQnl0ZXMsIGlucHV0LCBcImJ5dGVzXCIsIGAke2xlbmd0aDJ9YCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWltZVR5cGUvbWltZVR5cGUudHNcbmZ1bmN0aW9uIG1pbWVUeXBlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtaW1lX3R5cGVcIixcbiAgICBleHBlY3RzOiByZXF1aXJlbWVudC5tYXAoKG9wdGlvbikgPT4gYFwiJHtvcHRpb259XCJgKS5qb2luKFwiIHwgXCIpLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQuaW5jbHVkZXMoaW5wdXQudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWltZVR5cGUsIGlucHV0LCBcIk1JTUUgdHlwZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5MZW5ndGgvbWluTGVuZ3RoLnRzXG5mdW5jdGlvbiBtaW5MZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl9sZW5ndGhcIixcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID49IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWluTGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21pblNpemUvbWluU2l6ZS50c1xuZnVuY3Rpb24gbWluU2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWluX3NpemVcIixcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2l6ZSA+PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG1pblNpemUsIGlucHV0LCBcInNpemVcIiwgYCR7aW5wdXQuc2l6ZX1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5WYWx1ZS9taW5WYWx1ZS50c1xuZnVuY3Rpb24gbWluVmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl92YWx1ZVwiLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBzdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPj0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSA/IGlucHV0LnRvSlNPTigpIDogc3RyaW5naWZ5KGlucHV0KVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tdWx0aXBsZU9mL211bHRpcGxlT2YudHNcbmZ1bmN0aW9uIG11bHRpcGxlT2YocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm11bHRpcGxlX29mXCIsXG4gICAgZXhwZWN0czogYCUke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgJSB0aGlzLnJlcXVpcmVtZW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG11bHRpcGxlT2YsIGlucHV0LCBcIm11bHRpcGxlXCIsIGAke2lucHV0fWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdEJ5dGVzL25vdEJ5dGVzLnRzXG5mdW5jdGlvbiBub3RCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm90X2J5dGVzXCIsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBjb25zdCBsZW5ndGgyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGlucHV0KS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoMiAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBub3RCeXRlcywgaW5wdXQsIFwiYnl0ZXNcIiwgYCR7bGVuZ3RoMn1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9ub3RMZW5ndGgvbm90TGVuZ3RoLnRzXG5mdW5jdGlvbiBub3RMZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vdF9sZW5ndGhcIixcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggIT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbm90TGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdFNpemUvbm90U2l6ZS50c1xuZnVuY3Rpb24gbm90U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm90X3NpemVcIixcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5zaXplICE9PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG5vdFNpemUsIGlucHV0LCBcInNpemVcIiwgYCR7aW5wdXQuc2l6ZX1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9ub3RWYWx1ZS9ub3RWYWx1ZS50c1xuZnVuY3Rpb24gbm90VmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vdF92YWx1ZVwiLFxuICAgIGV4cGVjdHM6IGAhJHtyZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IHN0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA8IHRoaXMucmVxdWlyZW1lbnQgfHwgaW5wdXQgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBub3RWYWx1ZSxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIFwidmFsdWVcIixcbiAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlID8gaW5wdXQudG9KU09OKCkgOiBzdHJpbmdpZnkoaW5wdXQpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL29jdGFsL29jdGFsLnRzXG5mdW5jdGlvbiBvY3RhbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJvY3RhbFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE9DVEFMX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgb2N0YWwsIGlucHV0LCBcIm9jdGFsXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3JlZ2V4L3JlZ2V4LnRzXG5mdW5jdGlvbiByZWdleChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVnZXhcIixcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgcmVnZXgsIGlucHV0LCBcImZvcm1hdFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9zYWZlSW50ZWdlci9zYWZlSW50ZWdlci50c1xuZnVuY3Rpb24gc2FmZUludGVnZXIobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2FmZV9pbnRlZ2VyXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogTnVtYmVyLmlzU2FmZUludGVnZXIsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgc2FmZUludGVnZXIsIGlucHV0LCBcInNhZmUgaW50ZWdlclwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9zaXplL3NpemUudHNcbmZ1bmN0aW9uIHNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNpemVcIixcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKGlucHV0LnNpemUgPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgc2l6ZSwgaW5wdXQsIFwic2l6ZVwiLCBgJHtpbnB1dC5zaXplfWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3NvbWUvc29tZS50c1xuZnVuY3Rpb24gc29tZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic29tZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc29tZSh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBzb21lLCBpbnB1dCwgXCJpbnB1dFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9zdGFydHNXaXRoL3N0YXJ0c1dpdGgudHNcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0YXJ0c193aXRoXCIsXG4gICAgZXhwZWN0czogYFwiJHtyZXF1aXJlbWVudH1cImAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aCh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgc3RhcnRzV2l0aCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIFwic3RhcnRcIixcbiAgICAgICAgYFwiJHtpbnB1dC5zbGljZSgwLCB0aGlzLnJlcXVpcmVtZW50Lmxlbmd0aCl9XCJgXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3VsaWQvdWxpZC50c1xuZnVuY3Rpb24gdWxpZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1bGlkXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogVUxJRF9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIHVsaWQsIGlucHV0LCBcIlVMSURcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvdXJsL3VybC50c1xuZnVuY3Rpb24gdXJsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVybFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQoaW5wdXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBVUkwoaW5wdXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCB1cmwsIGlucHV0LCBcIlVSTFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy91dWlkL3V1aWQudHNcbmZ1bmN0aW9uIHV1aWQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidXVpZFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IFVVSURfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCB1dWlkLCBpbnB1dCwgXCJVVUlEXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3ZhbHVlL3ZhbHVlLnRzXG5mdW5jdGlvbiB2YWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IHN0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA8PSB0aGlzLnJlcXVpcmVtZW50ICYmIGlucHV0ID49IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGUgPyBpbnB1dC50b0pTT04oKSA6IHN0cmluZ2lmeShpbnB1dClcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZXhwb3J0IHtcbiAgQklDX1JFR0VYLFxuICBCcmFuZFN5bWJvbCxcbiAgQ1VJRDJfUkVHRVgsXG4gIERFQ0lNQUxfUkVHRVgsXG4gIEVNQUlMX1JFR0VYLFxuICBFTU9KSV9SRUdFWCxcbiAgSEVYQURFQ0lNQUxfUkVHRVgsXG4gIEhFWF9DT0xPUl9SRUdFWCxcbiAgSU1FSV9SRUdFWCxcbiAgSVBWNF9SRUdFWCxcbiAgSVBWNl9SRUdFWCxcbiAgSVNPX0RBVEVfUkVHRVgsXG4gIElTT19EQVRFX1RJTUVfUkVHRVgsXG4gIElTT19USU1FU1RBTVBfUkVHRVgsXG4gIElTT19USU1FX1JFR0VYLFxuICBJU09fVElNRV9TRUNPTkRfUkVHRVgsXG4gIElTT19XRUVLX1JFR0VYLFxuICBNQUM0OF9SRUdFWCxcbiAgTUFDNjRfUkVHRVgsXG4gIE9DVEFMX1JFR0VYLFxuICBVTElEX1JFR0VYLFxuICBVVUlEX1JFR0VYLFxuICBWYWxpRXJyb3IsXG4gIGFjdGlvbklzc3VlLFxuICBhY3Rpb25PdXRwdXQsXG4gIGFueSxcbiAgYW55QXN5bmMsXG4gIGFycmF5LFxuICBhcnJheUFzeW5jLFxuICBiaWMsXG4gIGJpZ2ludCxcbiAgYmlnaW50QXN5bmMsXG4gIGJsb2IsXG4gIGJsb2JBc3luYyxcbiAgYm9vbGVhbixcbiAgYm9vbGVhbkFzeW5jLFxuICBicmFuZCxcbiAgYnl0ZXMsXG4gIGNvZXJjZSxcbiAgY29lcmNlQXN5bmMsXG4gIGNyZWRpdENhcmQsXG4gIGN1aWQyLFxuICBjdXN0b20sXG4gIGN1c3RvbUFzeW5jLFxuICBkYXRlLFxuICBkYXRlQXN5bmMsXG4gIGRlY2ltYWwsXG4gIGRlZmF1bHRBcmdzLFxuICBkZWxldGVHbG9iYWxDb25maWcsXG4gIGRlbGV0ZUdsb2JhbE1lc3NhZ2UsXG4gIGRlbGV0ZVNjaGVtYU1lc3NhZ2UsXG4gIGRlbGV0ZVNwZWNpZmljTWVzc2FnZSxcbiAgZW1haWwsXG4gIGVtb2ppLFxuICBlbmRzV2l0aCxcbiAgZW51bUFzeW5jLFxuICBlbnVtXyxcbiAgZXZlcnksXG4gIGV4Y2x1ZGVzLFxuICBmYWxsYmFjayxcbiAgZmFsbGJhY2tBc3luYyxcbiAgZmluaXRlLFxuICBmbGF0dGVuLFxuICBmb3J3YXJkLFxuICBmb3J3YXJkQXN5bmMsXG4gIGdldERlZmF1bHQsXG4gIGdldERlZmF1bHRBc3luYyxcbiAgZ2V0RGVmYXVsdHMsXG4gIGdldERlZmF1bHRzQXN5bmMsXG4gIGdldEZhbGxiYWNrLFxuICBnZXRGYWxsYmFja0FzeW5jLFxuICBnZXRGYWxsYmFja3MsXG4gIGdldEZhbGxiYWNrc0FzeW5jLFxuICBnZXRHbG9iYWxDb25maWcsXG4gIGdldEdsb2JhbE1lc3NhZ2UsXG4gIGdldFNjaGVtYU1lc3NhZ2UsXG4gIGdldFNwZWNpZmljTWVzc2FnZSxcbiAgaGFzaCxcbiAgaGV4Q29sb3IsXG4gIGhleGFkZWNpbWFsLFxuICBpMThuLFxuICBpbWVpLFxuICBpbmNsdWRlcyxcbiAgaW5zdGFuY2UsXG4gIGluc3RhbmNlQXN5bmMsXG4gIGludGVnZXIsXG4gIGludGVyc2VjdCxcbiAgaW50ZXJzZWN0QXN5bmMsXG4gIGlwLFxuICBpcHY0LFxuICBpcHY2LFxuICBpcyxcbiAgaXNMdWhuQWxnbyxcbiAgaXNPZlR5cGUsXG4gIGlzb0RhdGUsXG4gIGlzb0RhdGVUaW1lLFxuICBpc29UaW1lLFxuICBpc29UaW1lU2Vjb25kLFxuICBpc29UaW1lc3RhbXAsXG4gIGlzb1dlZWssXG4gIGtleW9mLFxuICBsYXp5LFxuICBsYXp5QXN5bmMsXG4gIGxlbmd0aCxcbiAgbGl0ZXJhbCxcbiAgbGl0ZXJhbEFzeW5jLFxuICBtYWMsXG4gIG1hYzQ4LFxuICBtYWM2NCxcbiAgbWFwLFxuICBtYXBBc3luYyxcbiAgbWF4Qnl0ZXMsXG4gIG1heExlbmd0aCxcbiAgbWF4U2l6ZSxcbiAgbWF4VmFsdWUsXG4gIG1lcmdlLFxuICBtZXJnZUFzeW5jLFxuICBtaW1lVHlwZSxcbiAgbWluQnl0ZXMsXG4gIG1pbkxlbmd0aCxcbiAgbWluU2l6ZSxcbiAgbWluVmFsdWUsXG4gIG11bHRpcGxlT2YsXG4gIG5hbixcbiAgbmFuQXN5bmMsXG4gIG5ldmVyLFxuICBuZXZlckFzeW5jLFxuICBub25OdWxsYWJsZSxcbiAgbm9uTnVsbGFibGVBc3luYyxcbiAgbm9uTnVsbGlzaCxcbiAgbm9uTnVsbGlzaEFzeW5jLFxuICBub25PcHRpb25hbCxcbiAgbm9uT3B0aW9uYWxBc3luYyxcbiAgbm90Qnl0ZXMsXG4gIG5vdExlbmd0aCxcbiAgbm90U2l6ZSxcbiAgbm90VmFsdWUsXG4gIG51bGxBc3luYyxcbiAgbnVsbF8sXG4gIG51bGxhYmxlLFxuICBudWxsYWJsZUFzeW5jLFxuICBudWxsaXNoLFxuICBudWxsaXNoQXN5bmMsXG4gIG51bWJlcixcbiAgbnVtYmVyQXN5bmMsXG4gIG9iamVjdCxcbiAgb2JqZWN0QXN5bmMsXG4gIG9jdGFsLFxuICBvbWl0LFxuICBvbWl0QXN5bmMsXG4gIG9wdGlvbmFsLFxuICBvcHRpb25hbEFzeW5jLFxuICBwYXJzZSxcbiAgcGFyc2VBc3luYyxcbiAgcGFydGlhbCxcbiAgcGFydGlhbEFzeW5jLFxuICBwaWNrLFxuICBwaWNrQXN5bmMsXG4gIHBpY2tsaXN0LFxuICBwaWNrbGlzdEFzeW5jLFxuICBwaXBlUmVzdWx0LFxuICBwaXBlUmVzdWx0QXN5bmMsXG4gIHJlY29yZCxcbiAgcmVjb3JkQXN5bmMsXG4gIHJlZ2V4LFxuICByZXF1aXJlZCxcbiAgcmVxdWlyZWRBc3luYyxcbiAgcmVzdEFuZERlZmF1bHRBcmdzLFxuICBzYWZlSW50ZWdlcixcbiAgc2FmZVBhcnNlLFxuICBzYWZlUGFyc2VBc3luYyxcbiAgc2NoZW1hSXNzdWUsXG4gIHNjaGVtYVJlc3VsdCxcbiAgc2V0LFxuICBzZXRBc3luYyxcbiAgc2V0R2xvYmFsQ29uZmlnLFxuICBzZXRHbG9iYWxNZXNzYWdlLFxuICBzZXRTY2hlbWFNZXNzYWdlLFxuICBzZXRTcGVjaWZpY01lc3NhZ2UsXG4gIHNpemUsXG4gIHNvbWUsXG4gIHNwZWNpYWwsXG4gIHNwZWNpYWxBc3luYyxcbiAgc3RhcnRzV2l0aCxcbiAgc3RyaW5nLFxuICBzdHJpbmdBc3luYyxcbiAgc3RyaW5naWZ5LFxuICBzeW1ib2wsXG4gIHN5bWJvbEFzeW5jLFxuICB0b0N1c3RvbSxcbiAgdG9DdXN0b21Bc3luYyxcbiAgdG9Mb3dlckNhc2UsXG4gIHRvTWF4VmFsdWUsXG4gIHRvTWluVmFsdWUsXG4gIHRvVHJpbW1lZCxcbiAgdG9UcmltbWVkRW5kLFxuICB0b1RyaW1tZWRTdGFydCxcbiAgdG9VcHBlckNhc2UsXG4gIHRyYW5zZm9ybSxcbiAgdHJhbnNmb3JtQXN5bmMsXG4gIHR1cGxlLFxuICB0dXBsZUFzeW5jLFxuICB1bGlkLFxuICB1bmRlZmluZWRBc3luYyxcbiAgdW5kZWZpbmVkXyxcbiAgdW5pb24sXG4gIHVuaW9uQXN5bmMsXG4gIHVua25vd24sXG4gIHVua25vd25Bc3luYyxcbiAgdW53cmFwLFxuICB1cmwsXG4gIHV1aWQsXG4gIHZhbHVlLFxuICB2YXJpYW50LFxuICB2YXJpYW50QXN5bmMsXG4gIHZvaWRBc3luYyxcbiAgdm9pZF9cbn07XG4iXSwibmFtZXMiOlsiZmxhdHRlbiIsImFyZzEiLCJBcnJheSIsImlzQXJyYXkiLCJpc3N1ZXMiLCJyZWR1Y2UiLCJmbGF0RXJyb3JzIiwiaXNzdWUiLCJwYXRoIiwiZXZlcnkiLCJrZXkiLCJtYXAiLCJqb2luIiwibmVzdGVkIiwicHVzaCIsIm1lc3NhZ2UiLCJyb290IiwiVmFsaUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJCcmFuZFN5bWJvbCIsIlN5bWJvbCIsImJyYW5kIiwic2NoZW1hIiwiY29lcmNlIiwiYWN0aW9uIiwiX3BhcnNlIiwiaW5wdXQiLCJjb25maWciLCJjb2VyY2VBc3luYyIsImFjdGlvbklzc3VlIiwiY29udGV4dCIsInJlZmVyZW5jZSIsImxhYmVsIiwicmVjZWl2ZWQiLCJhY3Rpb25PdXRwdXQiLCJvdXRwdXQiLCJkZWZhdWx0QXJncyIsImFyZzIiLCJzdG9yZSIsInNldEdsb2JhbENvbmZpZyIsImdldEdsb2JhbENvbmZpZyIsImxhbmciLCJhYm9ydEVhcmx5IiwiYWJvcnRQaXBlRWFybHkiLCJza2lwUGlwZSIsImRlbGV0ZUdsb2JhbENvbmZpZyIsInN0b3JlMiIsInNldEdsb2JhbE1lc3NhZ2UiLCJNYXAiLCJzZXQiLCJnZXRHbG9iYWxNZXNzYWdlIiwiZ2V0IiwiZGVsZXRlR2xvYmFsTWVzc2FnZSIsImRlbGV0ZSIsInN0b3JlMyIsInNldFNjaGVtYU1lc3NhZ2UiLCJnZXRTY2hlbWFNZXNzYWdlIiwiZGVsZXRlU2NoZW1hTWVzc2FnZSIsInN0b3JlNCIsInNldFNwZWNpZmljTWVzc2FnZSIsImdldFNwZWNpZmljTWVzc2FnZSIsImRlbGV0ZVNwZWNpZmljTWVzc2FnZSIsImkxOG4iLCJOT05fRElHSVRfUkVHRVgiLCJpc0x1aG5BbGdvIiwibnVtYmVyMiIsInJlcGxhY2UiLCJsZW5ndGgyIiwibGVuZ3RoIiwiYml0Iiwic3VtIiwidmFsdWUyIiwiaXNPZlR5cGUiLCJ0eXBlIiwib2JqZWN0MiIsInNjaGVtYVJlc3VsdCIsInR5cGVkIiwic3RyaW5naWZ5IiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwaXBlSXNzdWUiLCJzY2hlbWFJc3N1ZTIiLCJyZWFzb24iLCJleHBlY3RlZCIsImV4cGVjdHMiLCJyZXF1aXJlbWVudCIsInBpcGVSZXN1bHQiLCJwaXBlIiwicmVzdWx0IiwiYWN0aW9uSXNzdWUyIiwicGlwZVJlc3VsdEFzeW5jIiwicmVzdEFuZERlZmF1bHRBcmdzIiwiYXJnMyIsImVycm9yMiIsInBpcGUyIiwiZXJyb3IiLCJzY2hlbWFJc3N1ZSIsIm90aGVyIiwiZ2V0RmFsbGJhY2siLCJpbmZvIiwiZmFsbGJhY2siLCJnZXRGYWxsYmFja0FzeW5jIiwiZmFsbGJhY2syIiwiZmFsbGJhY2tBc3luYyIsImZvcndhcmQiLCJ2YWxpZGF0aW9uIiwicGF0aExpc3QiLCJwYXRoSW5wdXQiLCJwYXRoVmFsdWUiLCJwYXRoSXRlbSIsIm9yaWdpbiIsInZhbHVlIiwiZm9yd2FyZEFzeW5jIiwiZ2V0RGVmYXVsdCIsImRlZmF1bHQiLCJnZXREZWZhdWx0QXN5bmMiLCJnZXREZWZhdWx0cyIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIml0ZW1zIiwiZ2V0RGVmYXVsdHNBc3luYyIsIlByb21pc2UiLCJhbGwiLCJnZXRGYWxsYmFja3MiLCJnZXRGYWxsYmFja3NBc3luYyIsImlzIiwiYW55IiwiYXN5bmMiLCJhbnlBc3luYyIsImFycmF5IiwiaXRlbSIsInVuc2hpZnQiLCJhcnJheUFzeW5jIiwiY2F0Y2giLCJiaWdpbnQiLCJiaWdpbnRBc3luYyIsImJsb2IiLCJCbG9iIiwiYmxvYkFzeW5jIiwiYm9vbGVhbiIsImJvb2xlYW5Bc3luYyIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZGF0ZUFzeW5jIiwiZW51bV8iLCJlbnVtX18iLCJ2YWx1ZXMiLCJlbnVtIiwiaW5jbHVkZXMiLCJlbnVtQXN5bmMiLCJlbnVtXzIiLCJpbnN0YW5jZSIsImNsYXNzXyIsImNsYXNzIiwiaW5zdGFuY2VBc3luYyIsIm1lcmdlT3V0cHV0cyIsIm91dHB1dDEiLCJvdXRwdXQyIiwiYXJyYXkyIiwiaW5kZXgiLCJpbnZhbGlkIiwiaW50ZXJzZWN0Iiwib3B0aW9ucyIsIlNldCIsIm9wdGlvbiIsIm91dHB1dHMiLCJpbnRlcnNlY3RBc3luYyIsImxhenkiLCJnZXR0ZXIiLCJsYXp5QXN5bmMiLCJsaXRlcmFsIiwibGl0ZXJhbF8iLCJsaXRlcmFsQXN5bmMiLCJsaXRlcmFsMiIsImFyZzQiLCJpbnB1dEtleSIsImlucHV0VmFsdWUiLCJrZXlSZXN1bHQiLCJ2YWx1ZVJlc3VsdCIsIm1hcEFzeW5jIiwiZnJvbSIsInZhbHVlMyIsIm5hbiIsIk51bWJlciIsIm5hbkFzeW5jIiwibmV2ZXIiLCJuZXZlckFzeW5jIiwibm9uTnVsbGFibGUiLCJ3cmFwcGVkIiwibm9uTnVsbGFibGVBc3luYyIsIm5vbk51bGxpc2giLCJub25OdWxsaXNoQXN5bmMiLCJub25PcHRpb25hbCIsIm5vbk9wdGlvbmFsQXN5bmMiLCJudWxsYWJsZSIsImRlZmF1bHRfIiwib3ZlcnJpZGUiLCJudWxsYWJsZUFzeW5jIiwibnVsbGlzaCIsIm51bGxpc2hBc3luYyIsIm51bGxfIiwibnVsbEFzeW5jIiwibnVtYmVyIiwibnVtYmVyQXN5bmMiLCJvYmplY3QiLCJyZXN0IiwiY2FjaGVkRW50cmllcyIsIm9iamVjdEFzeW5jIiwib3B0aW9uYWwiLCJvcHRpb25hbEFzeW5jIiwicGlja2xpc3QiLCJwaWNrbGlzdEFzeW5jIiwic3RyaW5nIiwic3RyaW5nQXN5bmMiLCJyZWNvcmRBcmdzIiwibWVzc2FnZTIiLCJCTE9DS0VEX0tFWVMiLCJyZWNvcmQiLCJyZWNvcmRBc3luYyIsImFkZCIsInNldEFzeW5jIiwic3BlY2lhbCIsImNoZWNrIiwic3BlY2lhbEFzeW5jIiwic3ltYm9sIiwic3ltYm9sQXN5bmMiLCJ0dXBsZSIsInR1cGxlQXN5bmMiLCJzbGljZSIsInVuZGVmaW5lZF8iLCJ1bmRlZmluZWRBc3luYyIsInN1Ymlzc3VlcyIsInJlc3VsdHMiLCJ1bmlvbiIsInZhbGlkUmVzdWx0IiwidW50eXBlZFJlc3VsdHMiLCJ0eXBlZFJlc3VsdHMiLCJmaXJzdFJlc3VsdCIsInVuaW9uQXN5bmMiLCJ1bmtub3duIiwidW5rbm93bkFzeW5jIiwidmFyaWFudCIsImNhY2hlZEV4cGVjdGVkS2V5IiwiZXhwZWN0ZWRLZXkiLCJ2YXJpYW50UmVzdWx0IiwicGFyc2VPcHRpb25zIiwib3B0aW9uczIiLCJrZXlTY2hlbWEiLCJkYXRhUmVzdWx0IiwidmFyaWFudEFzeW5jIiwidm9pZF8iLCJ2b2lkQXN5bmMiLCJrZXlvZiIsImtleXMiLCJtZXJnZSIsInNjaGVtYXMiLCJtZXJnZUFzeW5jIiwib21pdCIsImFyZzUiLCJzY2hlbWEyIiwib21pdEFzeW5jIiwicGFyc2UiLCJwYXJzZUFzeW5jIiwicGFydGlhbCIsInBhcnRpYWxBc3luYyIsInBpY2siLCJwaWNrQXN5bmMiLCJyZXF1aXJlZCIsInJlcXVpcmVkQXN5bmMiLCJzYWZlUGFyc2UiLCJzdWNjZXNzIiwic2FmZVBhcnNlQXN5bmMiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Bc3luYyIsInVud3JhcCIsIkJJQ19SRUdFWCIsIkNVSUQyX1JFR0VYIiwiREVDSU1BTF9SRUdFWCIsIkVNQUlMX1JFR0VYIiwiRU1PSklfUkVHRVgiLCJIRVhBREVDSU1BTF9SRUdFWCIsIkhFWF9DT0xPUl9SRUdFWCIsIklNRUlfUkVHRVgiLCJJUFY0X1JFR0VYIiwiSVBWNl9SRUdFWCIsIklTT19EQVRFX1JFR0VYIiwiSVNPX0RBVEVfVElNRV9SRUdFWCIsIklTT19USU1FX1JFR0VYIiwiSVNPX1RJTUVfU0VDT05EX1JFR0VYIiwiSVNPX1RJTUVTVEFNUF9SRUdFWCIsIklTT19XRUVLX1JFR0VYIiwiTUFDNDhfUkVHRVgiLCJNQUM2NF9SRUdFWCIsIk9DVEFMX1JFR0VYIiwiVUxJRF9SRUdFWCIsIlVVSURfUkVHRVgiLCJ0b0N1c3RvbSIsInRvQ3VzdG9tQXN5bmMiLCJ0b0xvd2VyQ2FzZSIsInRvTG9jYWxlTG93ZXJDYXNlIiwidG9NYXhWYWx1ZSIsInRvTWluVmFsdWUiLCJ0b1RyaW1tZWQiLCJ0cmltIiwidG9UcmltbWVkRW5kIiwidHJpbUVuZCIsInRvVHJpbW1lZFN0YXJ0IiwidHJpbVN0YXJ0IiwidG9VcHBlckNhc2UiLCJiaWMiLCJ0ZXN0IiwiYnl0ZXMiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIlNBTklUSVpFX1JFR0VYIiwiUFJPVklERVJfUkVHRVhfTElTVCIsImNyZWRpdENhcmQiLCJzYW5pdGl6ZWQiLCJzb21lIiwicmVnZXgyIiwiY3VpZDIiLCJjdXN0b20iLCJjdXN0b21Bc3luYyIsImRlY2ltYWwiLCJlbWFpbCIsImVtb2ppIiwiZW5kc1dpdGgiLCJleGNsdWRlcyIsImZpbml0ZSIsImlzRmluaXRlIiwiSEFTSF9MRU5HVEhTIiwibWQ0IiwibWQ1Iiwic2hhMSIsInNoYTI1NiIsInNoYTM4NCIsInNoYTUxMiIsInJpcGVtZDEyOCIsInJpcGVtZDE2MCIsInRpZ2VyMTI4IiwidGlnZXIxNjAiLCJ0aWdlcjE5MiIsImNyYzMyIiwiY3JjMzJiIiwiYWRsZXIzMiIsImhhc2giLCJ0eXBlcyIsIlJlZ0V4cCIsImhleGFkZWNpbWFsIiwiaGV4Q29sb3IiLCJpbWVpIiwiaW50ZWdlciIsImlzSW50ZWdlciIsImlwIiwiaXB2NCIsImlwdjYiLCJpc29EYXRlIiwiaXNvRGF0ZVRpbWUiLCJpc29UaW1lIiwiaXNvVGltZVNlY29uZCIsImlzb1RpbWVzdGFtcCIsImlzb1dlZWsiLCJtYWMiLCJtYWM0OCIsIm1hYzY0IiwibWF4Qnl0ZXMiLCJtYXhMZW5ndGgiLCJtYXhTaXplIiwic2l6ZSIsIm1heFZhbHVlIiwidG9KU09OIiwibWluQnl0ZXMiLCJtaW1lVHlwZSIsIm1pbkxlbmd0aCIsIm1pblNpemUiLCJtaW5WYWx1ZSIsIm11bHRpcGxlT2YiLCJub3RCeXRlcyIsIm5vdExlbmd0aCIsIm5vdFNpemUiLCJub3RWYWx1ZSIsIm9jdGFsIiwicmVnZXgiLCJzYWZlSW50ZWdlciIsImlzU2FmZUludGVnZXIiLCJzdGFydHNXaXRoIiwidWxpZCIsInVybCIsIlVSTCIsInV1aWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/valibot/dist/index.js\n");

/***/ })

};
;